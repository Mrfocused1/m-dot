// ============================================================================
// GAP TAG - 3D Endless Runner (Temple Run Style)
// ============================================================================

import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Debug mode
const DEBUG = true;

// ============================================================================
// LEVEL CONFIGURATION - STARTING POSITIONS
// ============================================================================
// IMPORTANT: These are the verified starting positions for each game mode
// DO NOT CHANGE unless explicitly updated by the user

const LEVEL_CONFIG = {
    // ANIMATION TESTING MODE (Tunnel)
    // ⭐ PERFECT SIZE CONFIRMED - 2026-01-24 at 17:37
    // Tunnel scale: (100, 100, 100) - DO NOT CHANGE
    // Starting position: X: -29.05, Z: -200.28 (user's saved position)
    ANIMATION_TESTING_START: {
        x: -48.66,   // User's preferred starting position (centered view)
        y: 1.0,
        z: -231.69,  // User's exact starting Z from dashboard
        rotation: 0,  // Face toward exit (positive Z direction)
        description: 'Inside tunnel - user preferred centered starting position'
    }
};

// ============================================================================
// THREE.JS SETUP
// ============================================================================

let scene, camera, renderer;
let player, enemy;
let playerMixer, enemyMixer;
let playerModel, enemyModel;
let clock;

// Game world
const LANE_WIDTH = 3;
const LANE_POSITIONS = [-LANE_WIDTH, 0, LANE_WIDTH];
const GAME_SPEED = 15;

// Shooting game variables (now maze exploration)
let shooterModel, shooterMixer;
let bullets = [];
let enemies = [];
let mazeWalls = [];
let exitMarker = null;

// Urban environment
let urbanEnvironment = null;
let environmentColliders = []; // Collision boxes for environment objects
let debugCollisionBoxes = []; // Visual wireframes for debugging

// Maze layout (1 = wall, 0 = corridor, 2 = exit)
const MAZE_LAYOUT = [
    [1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1]
];

const TILE_SIZE = 3;
const WALL_HEIGHT = 3;

// ============================================================================
// GAME STATE
// ============================================================================

const GameState = {
    isRunning: false,
    isPaused: false,
    isGameOver: false,
    currentMode: 'CHASE',
    score: 0,
    highScore: 0,
    lives: 3,
    maxLives: 3,
    screen: 'START',
    isNewHighScore: false,
    gameSpeed: GAME_SPEED,
    selectedLevel: null // 'chase' or 'brawl'
};

// ============================================================================
// INPUT SYSTEM
// ============================================================================

const Input = {
    touchActive: false,
    touchSide: null,
    touchX: 0,
    touchY: 0,
    inputProcessed: false,
    canvas: null,

    init() {
        console.log('Input system initializing...');

        // CRITICAL FIX: Attach events to canvas element, not document
        // This prevents UI overlays from blocking input events
        // The canvas reference is set after renderer is created
        this.canvas = renderer.domElement;
        this.canvas.id = 'gameCanvas';
        this.canvas.style.touchAction = 'none'; // Prevent browser touch gestures

        // Touch events on canvas with passive: false to allow preventDefault
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
        this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });

        // Mouse events on canvas
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));

        // Keyboard events must stay on document (canvas doesn't receive key events without focus)
        document.addEventListener('keydown', this.handleKeyDown.bind(this));

        // Make canvas focusable for better event handling
        this.canvas.tabIndex = 1;
        this.canvas.style.outline = 'none';

        console.log('Input system initialized! Event listeners attached to canvas:', this.canvas.id);
    },

    handleTouchStart(e) {
        e.preventDefault();
        e.stopPropagation();
        const touch = e.touches[0];
        this.touchX = touch.clientX;
        this.touchY = touch.clientY;
        this.touchActive = true;
        this.touchSide = this.touchX < window.innerWidth / 2 ? 'LEFT' : 'RIGHT';
        console.log('Touch START on canvas: side=' + this.touchSide + ', x=' + this.touchX);
    },

    handleTouchMove(e) {
        // Prevent scrolling/zooming while touching the game canvas
        e.preventDefault();
        e.stopPropagation();
    },

    handleTouchEnd(e) {
        e.preventDefault();
        e.stopPropagation();
        // Don't immediately clear - let game loop process it first
        setTimeout(() => {
            this.touchActive = false;
            this.touchSide = null;
        }, 100);
    },

    handleMouseDown(e) {
        // Only process left mouse button
        if (e.button !== 0) return;

        e.preventDefault();
        e.stopPropagation();

        console.log('Mouse DOWN on canvas:', e.clientX, e.clientY);
        this.touchX = e.clientX;
        this.touchY = e.clientY;
        this.touchActive = true;
        this.touchSide = this.touchX < window.innerWidth / 2 ? 'LEFT' : 'RIGHT';
        console.log('Input.handleMouseDown: touchSide=' + this.touchSide + ', x=' + this.touchX + ', touchActive=' + this.touchActive);
    },

    handleMouseUp(e) {
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();

        // Don't immediately clear - let game loop process it first
        setTimeout(() => {
            this.touchActive = false;
            this.touchSide = null;
        }, 100);
    },

    handleKeyDown(e) {
        if (e.key === 'ArrowLeft') {
            this.touchSide = 'LEFT';
            this.touchActive = true;
            setTimeout(() => { this.touchActive = false; }, 100);
        } else if (e.key === 'ArrowRight') {
            this.touchSide = 'RIGHT';
            this.touchActive = true;
            setTimeout(() => { this.touchActive = false; }, 100);
        }
    }
};

// ============================================================================
// PLAYER CONTROLLER
// ============================================================================

const PlayerController = {
    currentLane: 1,
    targetLane: 1,
    laneChangeSpeed: 10,
    isInvincible: false,
    invincibilityTimer: 0,

    init() {
        this.currentLane = 1;
        this.targetLane = 1;
        this.isInvincible = false;
        this.invincibilityTimer = 0;
    },

    update(dt) {
        // Handle input
        if (Input.touchActive && !Input.inputProcessed) {
            if (Input.touchSide === 'LEFT' && this.targetLane > 0) {
                this.targetLane--;
                Input.inputProcessed = true;
            } else if (Input.touchSide === 'RIGHT' && this.targetLane < 2) {
                this.targetLane++;
                Input.inputProcessed = true;
            }
        }

        if (!Input.touchActive) {
            Input.inputProcessed = false;
        }

        // Smooth lane movement
        if (playerModel) {
            const targetX = LANE_POSITIONS[this.targetLane];
            const diff = targetX - playerModel.position.x;

            if (Math.abs(diff) > 0.01) {
                playerModel.position.x += diff * this.laneChangeSpeed * dt;
            } else {
                playerModel.position.x = targetX;
            }
        }

        // Update invincibility
        if (this.isInvincible) {
            this.invincibilityTimer -= dt;
            if (this.invincibilityTimer <= 0) {
                this.isInvincible = false;
                this.invincibilityTimer = 0;
            }
        }
    }
};

// ============================================================================
// ENEMY CONTROLLER
// ============================================================================

const EnemyController = {
    currentLane: 1,
    targetLane: 1,
    laneChangeSpeed: 8,
    laneChangeTimer: 0,
    laneChangeInterval: 2,
    distanceFromPlayer: -15, // Behind player in chase mode

    init() {
        this.currentLane = 1;
        this.targetLane = 1;
        this.laneChangeTimer = 0;
    },

    update(dt) {
        this.laneChangeTimer += dt;

        if (this.laneChangeTimer >= this.laneChangeInterval) {
            this.laneChangeTimer = 0;
            const rand = Math.random();

            if (rand < 0.33 && this.targetLane > 0) {
                this.targetLane--;
            } else if (rand > 0.66 && this.targetLane < 2) {
                this.targetLane++;
            }

            this.laneChangeInterval = 1.5 + Math.random() * 1.5;
        }

        // Smooth lane movement
        if (enemyModel) {
            const targetX = LANE_POSITIONS[this.targetLane];
            const diff = targetX - enemyModel.position.x;

            if (Math.abs(diff) > 0.01) {
                enemyModel.position.x += diff * this.laneChangeSpeed * dt;
            } else {
                enemyModel.position.x = targetX;
            }

            // Position behind/ahead of player based on mode
            const targetZ = GameState.currentMode === 'CHASE' ? this.distanceFromPlayer : -this.distanceFromPlayer;
            enemyModel.position.z = targetZ;
        }
    }
};

// ============================================================================
// MAZE CONTROLLER (for Maze Exploration mode)
// ============================================================================

const MazeController = {
    velocity: { x: 0, z: 0 },
    speed: 8,
    keysPressed: { up: false, down: false, left: false, right: false },
    manualRotation: null, // For manual direction control

    init() {
        this.velocity = { x: 0, z: 0 };
        this.manualRotation = null;
        console.log('Animation Controller initialized');

        // Add keyboard listeners
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
    },

    handleKeyDown(e) {
        // Prevent default browser behavior for game keys (especially spacebar which scrolls page)
        if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key)) {
            e.preventDefault();
        }

        switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                this.keysPressed.up = true;
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                this.keysPressed.down = true;
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                this.keysPressed.left = true;
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                this.keysPressed.right = true;
                break;
            case ' ':
                // Spacebar - shoot
                this.shoot();
                break;

            // MANUAL DIRECTION CONTROLS
            case '1':
                // Face UP (north, toward -Z)
                this.manualRotation = 0;
                console.log('Manual rotation: FORWARD (0°)');
                break;
            case '2':
                // Face RIGHT (east, toward +X)
                this.manualRotation = Math.PI / 2;
                console.log('Manual rotation: RIGHT (90°)');
                break;
            case '3':
                // Face DOWN (south, toward +Z)
                this.manualRotation = Math.PI;
                console.log('Manual rotation: BACKWARD (180°)');
                break;
            case '4':
                // Face LEFT (west, toward -X)
                this.manualRotation = -Math.PI / 2;
                console.log('Manual rotation: LEFT (-90°)');
                break;
            case '0':
                // Clear manual rotation OR switch to V0 if Shift is held
                if (event.shiftKey) {
                    CollisionSystem.setVersion(0);
                } else {
                    this.manualRotation = null;
                    console.log('Manual rotation: CLEARED (auto mode)');
                }
                break;
            case '5':
                CollisionSystem.setVersion(1);
                break;
            case '6':
                CollisionSystem.setVersion(2);
                break;
        }
    },

    shoot() {
        console.log('BANG! Officer shooting...');

        // Alternate flash color between yellow and white
        if (muzzleFlash) {
            const flashColor = flashColorToggle ? 0xffff00 : 0xffffff; // Yellow or white
            muzzleFlash.material.color.setHex(flashColor);

            // Update point light color too
            if (muzzleFlash.children[0]) {
                muzzleFlash.children[0].color.setHex(flashColor);
            }

            muzzleFlash.visible = true;
            flashColorToggle = !flashColorToggle; // Toggle for next shot

            // Hide after short duration
            setTimeout(() => {
                if (muzzleFlash) muzzleFlash.visible = false;
            }, 50); // 50ms flash
        }

        // Fire bullet projectile
        this.fireBullet();

        // Create smoke particles
        this.createSmokeEffect();

        // Eject bullet casing
        this.ejectBulletCasing();

        // Play shooting animation if available
        if (officerActions.shoot) {
            // Play shoot animation once, then return to previous state
            const previousAnim = officerActions.current;

            if (officerActions[officerActions.current]) {
                officerActions[officerActions.current].fadeOut(0.1);
            }

            officerActions.shoot.reset();
            officerActions.shoot.setLoop(THREE.LoopOnce, 1);
            officerActions.shoot.clampWhenFinished = true;
            officerActions.shoot.fadeIn(0.1);
            officerActions.shoot.play();

            officerActions.current = 'shoot';

            // Return to previous animation after shoot completes
            setTimeout(() => {
                if (officerActions[previousAnim]) {
                    officerActions.shoot.fadeOut(0.1);
                    officerActions[previousAnim].reset().fadeIn(0.1).play();
                    officerActions.current = previousAnim;
                }
            }, officerActions.shoot._clip.duration * 1000);
        }
    },

    createSmokeEffect() {
        if (!subMachineGun) return;

        // Get world position of gun barrel (where muzzle flash is)
        const barrelPos = new THREE.Vector3();
        if (muzzleFlash) {
            muzzleFlash.getWorldPosition(barrelPos);
        } else {
            subMachineGun.getWorldPosition(barrelPos);
        }

        // Create 5-8 smoke particles
        const numParticles = 5 + Math.floor(Math.random() * 4);
        for (let i = 0; i < numParticles; i++) {
            const smokeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const smokeMaterial = new THREE.MeshBasicMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.6
            });
            const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);

            // Position at gun barrel
            smoke.position.copy(barrelPos);

            // Add random velocity (spread outward from gun)
            const spread = 0.5;
            smoke.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * spread,
                Math.random() * 2 + 1, // Upward bias
                -Math.random() * 2 - 1 // Forward (in shooting direction)
            );

            // Rotate velocity based on shooter's rotation
            smoke.userData.velocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), shooterModel.rotation.y);

            smoke.userData.lifetime = 0;
            smoke.userData.maxLifetime = 1.0 + Math.random() * 0.5; // 1-1.5 seconds

            scene.add(smoke);
            smokeParticles.push(smoke);
        }
    },

    fireBullet() {
        if (!muzzleFlash || !shooterModel) return;

        // Get muzzle flash world position (gun barrel tip)
        const barrelPos = new THREE.Vector3();
        muzzleFlash.getWorldPosition(barrelPos);

        // Create bullet (very small silver cylinder/capsule - realistic bullet size)
        const bulletGeometry = new THREE.CapsuleGeometry(0.015, 0.08, 4, 8);
        const bulletMaterial = new THREE.MeshStandardMaterial({
            color: 0xc0c0c0, // Silver color
            metalness: 0.9,
            roughness: 0.1,
            emissive: 0x404040 // Slight glow
        });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Position at gun barrel tip
        bullet.position.copy(barrelPos);

        // Calculate shooting direction (forward from officer's facing direction)
        const shootAngle = shooterModel.rotation.y;
        const bulletSpeed = 50; // Very fast
        bullet.userData.velocity = new THREE.Vector3(
            Math.sin(shootAngle) * bulletSpeed,
            0, // Straight ahead (no drop for now)
            Math.cos(shootAngle) * bulletSpeed
        );

        // Orient bullet in direction of travel
        bullet.rotation.x = Math.PI / 2; // Point capsule forward
        bullet.rotation.y = shootAngle;

        bullet.userData.lifetime = 0;
        bullet.userData.maxLifetime = 3; // 3 seconds max range

        scene.add(bullet);
        bullets.push(bullet);

        console.log('Bullet fired!');
    },

    ejectBulletCasing() {
        if (!subMachineGun || !shooterModel) return;

        // Get gun position in world space
        const gunPos = new THREE.Vector3();
        subMachineGun.getWorldPosition(gunPos);

        // Create bullet casing (very small cylinder - realistic shell casing size)
        const casingGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.04, 8);
        const casingMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37, // Golden brass color
            metalness: 0.8,
            roughness: 0.2
        });
        const casing = new THREE.Mesh(casingGeometry, casingMaterial);
        casing.castShadow = true;

        // Position at gun (slightly to the right for ejection port)
        casing.position.copy(gunPos);
        casing.position.y += 0.5; // Slightly higher

        // Ejection velocity (to the right and up)
        const ejectSpeed = 3;
        const ejectAngle = shooterModel.rotation.y + Math.PI / 2; // 90 degrees right
        casing.userData.velocity = new THREE.Vector3(
            Math.cos(ejectAngle) * ejectSpeed + (Math.random() - 0.5),
            2 + Math.random(), // Upward
            Math.sin(ejectAngle) * ejectSpeed + (Math.random() - 0.5)
        );

        // Random rotation velocity for tumbling effect
        casing.userData.rotationVelocity = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
        );

        casing.userData.onGround = false;
        casing.userData.lifetime = 0;

        scene.add(casing);
        bulletCasings.push(casing);
    },

    handleKeyUp(e) {
        switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                this.keysPressed.up = false;
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                this.keysPressed.down = false;
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                this.keysPressed.left = false;
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                this.keysPressed.right = false;
                break;
        }
    },

    update(delta) {
        if (!shooterModel) return;

        // Calculate velocity based on key presses
        this.velocity.x = 0;
        this.velocity.z = 0;

        // RALPH FIX: Tunnel now runs entrance (low Z) to exit (high Z)
        // So forward = positive Z (toward exit)
        if (this.keysPressed.up) this.velocity.z += this.speed;  // W moves forward (positive Z - toward exit)
        if (this.keysPressed.down) this.velocity.z -= this.speed; // S moves backward (negative Z - toward entrance)
        // Fixed left/right controls (were inverted)
        if (this.keysPressed.left) this.velocity.x += this.speed; // A moves left (positive X)
        if (this.keysPressed.right) this.velocity.x -= this.speed; // D moves right (negative X)

        // Normalize diagonal movement
        if (this.velocity.x !== 0 && this.velocity.z !== 0) {
            const factor = 1 / Math.sqrt(2);
            this.velocity.x *= factor;
            this.velocity.z *= factor;
        }

        // Calculate new position
        const newX = shooterModel.position.x + this.velocity.x * delta;
        const newZ = shooterModel.position.z + this.velocity.z * delta;

        // Check collision with environment
        const characterRadius = 0.5; // Officer collision radius

        // Use CollisionSystem (supports multiple versions)
        if (!CollisionSystem.checkCollision(newX, newZ, characterRadius)) {
            // No collision - update position
            shooterModel.position.x = newX;
            shooterModel.position.z = newZ;
        } else {
            // Collision detected - try sliding along walls
            // Try X movement only
            if (!CollisionSystem.checkCollision(newX, shooterModel.position.z, characterRadius)) {
                shooterModel.position.x = newX;
            }
            // Try Z movement only
            if (!CollisionSystem.checkCollision(shooterModel.position.x, newZ, characterRadius)) {
                shooterModel.position.z = newZ;
            }
        }

        // Keep within bounds - allow full tunnel traversal
        const maxBound = 250; // Increased to accommodate tunnel (extends to ±200)
        const entranceBoundary = -232; // Entrance wall - cannot go backward past this

        shooterModel.position.x = Math.max(-maxBound, Math.min(maxBound, shooterModel.position.x));
        shooterModel.position.z = Math.max(entranceBoundary, Math.min(maxBound, shooterModel.position.z)); // Blocked at entrance

        // Zero backward velocity if at entrance wall
        if (shooterModel.position.z <= entranceBoundary && this.velocity.z < 0) {
            this.velocity.z = 0; // Stop backward movement
        }

        // Check if character is moving
        const isMoving = this.velocity.x !== 0 || this.velocity.z !== 0;

        // Rotate character - use manual rotation if set, otherwise use movement direction
        if (this.manualRotation !== null) {
            // Manual rotation mode (use number keys 1-4)
            shooterModel.rotation.y = this.manualRotation;
        } else if (isMoving) {
            // Auto rotation based on movement direction
            const angle = Math.atan2(this.velocity.x, this.velocity.z);
            shooterModel.rotation.y = angle;
        }

        // Switch between idle and run animations
        this.updateAnimation(isMoving);
    },

    updateAnimation(isMoving) {
        // Don't interrupt shooting animation
        if (officerActions.current === 'shoot') return;

        // Determine animation based on movement
        const targetAnim = isMoving ? 'run' : 'idle';

        // Switch animations with smooth cross-fade
        if (officerActions.current !== targetAnim && officerActions[targetAnim]) {
            // Fade out current animation
            if (officerActions[officerActions.current]) {
                officerActions[officerActions.current].fadeOut(0.3);
            }

            // Fade in new animation
            officerActions[targetAnim].reset().fadeIn(0.3).play();
            officerActions.current = targetAnim;
        }
    }
};


// ============================================================================
// OBSTACLES
// ============================================================================

const obstacles = [];
const obstaclePool = [];

class Obstacle {
    constructor() {
        const geometry = new THREE.BoxGeometry(1.5, 2, 1.5);
        const material = new THREE.MeshLambertMaterial({ color: 0x66bb6a });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.active = false;
        this.lane = 0;
    }

    activate(lane, zPosition) {
        this.lane = lane;
        this.mesh.position.x = LANE_POSITIONS[lane];
        this.mesh.position.y = 1;
        this.mesh.position.z = zPosition;
        this.active = true;
        scene.add(this.mesh);
    }

    deactivate() {
        this.active = false;
        scene.remove(this.mesh);
    }

    update(dt) {
        if (this.active) {
            this.mesh.position.z += GameState.gameSpeed * dt;

            // Remove if behind camera
            if (this.mesh.position.z > 10) {
                this.deactivate();
            }
        }
    }
}

const ObstacleManager = {
    spawnTimer: 0,
    spawnInterval: 1.5,

    init() {
        for (let i = 0; i < 20; i++) {
            obstaclePool.push(new Obstacle());
        }
    },

    spawn() {
        const obstacle = obstaclePool.find(o => !o.active);
        if (obstacle) {
            const lane = Math.floor(Math.random() * 3);
            obstacle.activate(lane, -50);
            obstacles.push(obstacle);
        }
    },

    update(dt) {
        this.spawnTimer += dt;

        if (this.spawnTimer >= this.spawnInterval) {
            this.spawnTimer = 0;
            this.spawn();
        }

        obstacles.forEach(obs => obs.update(dt));
    },

    reset() {
        obstacles.forEach(obs => obs.deactivate());
        obstacles.length = 0;
        this.spawnTimer = 0;
    }
};

// ============================================================================
// ENVIRONMENT (Road/Path)
// ============================================================================

const roadSegments = [];
let roadModels = []; // Array to hold 3D road model instances
let roadModelTemplate = null; // Loaded GLB template to clone

class RoadSegment {
    constructor(zPosition) {
        const geometry = new THREE.PlaneGeometry(15, 20);
        const material = new THREE.MeshLambertMaterial({
            color: 0x404040,
            side: THREE.DoubleSide
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.x = -Math.PI / 2;
        this.mesh.position.y = 0;
        this.mesh.position.z = zPosition;
        this.mesh.receiveShadow = true;
        scene.add(this.mesh);

        // Lane markers
        this.createLaneMarkers(zPosition);
    }

    createLaneMarkers(zPosition) {
        const markerGeometry = new THREE.BoxGeometry(0.2, 0.1, 2);
        const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

        // Left lane marker
        const leftMarker = new THREE.Mesh(markerGeometry, markerMaterial);
        leftMarker.position.set(-LANE_WIDTH / 2, 0.05, zPosition);
        scene.add(leftMarker);

        // Right lane marker
        const rightMarker = new THREE.Mesh(markerGeometry, markerMaterial);
        rightMarker.position.set(LANE_WIDTH / 2, 0.05, zPosition);
        scene.add(rightMarker);
    }

    update(dt) {
        this.mesh.position.z += GameState.gameSpeed * dt;

        if (this.mesh.position.z > 20) {
            this.mesh.position.z -= 60;
        }
    }
}

const EnvironmentManager = {
    init() {
        // Load 3D road model first
        this.loadRoadModel();

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Fog for depth
        scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);
    },

    loadRoadModel() {
        console.log('Loading 3D road model...');

        const loader = new GLTFLoader();

        loader.load(
            'road-street.glb',
            // onLoad
            (gltf) => {
                roadModelTemplate = gltf.scene;

                console.log('Road model loaded successfully');

                // Calculate bounding box to understand size
                const box = new THREE.Box3().setFromObject(roadModelTemplate);
                const size = box.getSize(new THREE.Vector3());
                console.log('Road model size:', {
                    x: size.x.toFixed(2),
                    y: size.y.toFixed(2),
                    z: size.z.toFixed(2)
                });

                // Create multiple road segments
                this.createRoadSegments();
            },
            // onProgress
            (xhr) => {
                if (xhr.lengthComputable) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                    console.log('Road loading: ' + percent + '%');
                }
            },
            // onError
            (error) => {
                console.error('Error loading road model:', error);
                // Fallback to simple road segments
                this.createFallbackRoad();
            }
        );
    },

    createRoadSegments() {
        // Create 3 repeating road segments
        for (let i = 0; i < 3; i++) {
            const roadClone = roadModelTemplate.clone();

            // Position road segments in sequence
            roadClone.position.set(0, 0, -20 * i);

            // Enable shadows
            roadClone.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(roadClone);
            roadModels.push(roadClone);
        }

        console.log('Created', roadModels.length, 'road segments');
    },

    createFallbackRoad() {
        // Fallback to simple road if GLB fails to load
        console.log('Using fallback simple road');
        for (let i = 0; i < 3; i++) {
            roadSegments.push(new RoadSegment(-20 * i));
        }
    },

    update(dt) {
        // Update 3D road models
        roadModels.forEach(roadModel => {
            roadModel.position.z += GameState.gameSpeed * dt;

            // Loop back when road goes too far
            if (roadModel.position.z > 20) {
                roadModel.position.z -= 60;
            }
        });

        // Update fallback road segments if they exist
        roadSegments.forEach(segment => segment.update(dt));
    }
};

// ============================================================================
// CHARACTER LOADING
// ============================================================================

function loadPlayerCharacter() {
    const loader = new FBXLoader();

    loader.load('Fast Run.fbx', (fbx) => {
        playerModel = fbx;
        playerModel.scale.set(0.01, 0.01, 0.01);
        playerModel.position.set(0, 1.0, 0); // Lifted up by 1 unit so feet are on ground
        playerModel.rotation.y = Math.PI;

        playerModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // Keep original material with textures
            }
        });

        scene.add(playerModel);

        // Setup animation with proper looping
        playerMixer = new THREE.AnimationMixer(playerModel);
        if (fbx.animations && fbx.animations.length > 0) {
            const clip = fbx.animations[0];

            // === DEBUG: Log animation data ===
            console.log('=== PLAYER Animation Debug Info ===');
            console.log('Clip name:', clip.name);
            console.log('Clip duration:', clip.duration);
            console.log('Number of tracks:', clip.tracks.length);

            if (clip.tracks.length > 0) {
                const firstTrack = clip.tracks[0];
                console.log('First track name:', firstTrack.name);
                console.log('First track times (first 5):', firstTrack.times.slice(0, 5));
                console.log('First track times (last 5):', firstTrack.times.slice(-5));
                console.log('Min time:', Math.min(...firstTrack.times));
                console.log('Max time:', Math.max(...firstTrack.times));
            }

            // === SOLUTION: Normalize track times (remove timeline offset) ===
            let minTime = Infinity;
            clip.tracks.forEach(track => {
                const trackMinTime = track.times[0];
                if (trackMinTime < minTime) {
                    minTime = trackMinTime;
                }
            });

            // Normalize all track times to start at 0
            if (minTime > 0.001) { // Only normalize if there's a significant offset
                console.log('PLAYER: Normalizing animation - removing offset of:', minTime);
                clip.tracks.forEach(track => {
                    for (let i = 0; i < track.times.length; i++) {
                        track.times[i] -= minTime;
                    }
                });
                // Recalculate duration
                clip.duration = clip.tracks.reduce((max, track) => {
                    return Math.max(max, track.times[track.times.length - 1]);
                }, 0);
                console.log('PLAYER: New duration after normalization:', clip.duration);
            }

            // === RALPH'S FIX: Remove the Hips position track that causes flashing ===
            console.log('PLAYER: Filtering animation tracks...');
            const originalTrackCount = clip.tracks.length;
            clip.tracks = clip.tracks.filter(track => {
                // Remove ONLY the root Hips position track
                // This track moves the character in world space, causing visual glitches when looping
                if (track.name === 'mixamorigHips.position') {
                    console.log('PLAYER: ❌ Removing:', track.name);
                    return false;
                }
                return true; // Keep all rotation tracks
            });
            console.log(`PLAYER: Removed ${originalTrackCount - clip.tracks.length} track(s), kept ${clip.tracks.length}`);

            // === SOLUTION: Try using original clip without subclip first ===
            const action = playerMixer.clipAction(clip);
            action.setLoop(THREE.LoopRepeat, Infinity);
            action.clampWhenFinished = false;
            action.timeScale = 1.0; // Normal speed
            action.reset();
            action.play();
            console.log('PLAYER: Animation playing with normalized clip, duration:', clip.duration);
        }

        console.log('Player character loaded');
    }, undefined, (error) => {
        console.error('Error loading player FBX:', error);
        // Fallback to simple cube
        createFallbackPlayer();
    });
}

function createFallbackPlayer() {
    const geometry = new THREE.BoxGeometry(1, 2, 1);
    const material = new THREE.MeshLambertMaterial({ color: 0x4fc3f7 });
    playerModel = new THREE.Mesh(geometry, material);
    playerModel.position.set(0, 1.0, 0);
    playerModel.castShadow = true;
    scene.add(playerModel);
}

function loadEnemyCharacter() {
    const loader = new FBXLoader();

    loader.load('Fast Run.fbx', (fbx) => {
        enemyModel = fbx;
        enemyModel.scale.set(0.01, 0.01, 0.01);
        enemyModel.position.set(0, 1.0, -15); // Lifted up by 1 unit so feet are on ground
        enemyModel.rotation.y = Math.PI;

        enemyModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // Keep original material with textures
            }
        });

        scene.add(enemyModel);

        // Setup animation with proper looping
        enemyMixer = new THREE.AnimationMixer(enemyModel);
        if (fbx.animations && fbx.animations.length > 0) {
            const clip = fbx.animations[0];

            // === DEBUG: Log animation data ===
            console.log('=== ENEMY Animation Debug Info ===');
            console.log('Clip name:', clip.name);
            console.log('Clip duration:', clip.duration);
            console.log('Number of tracks:', clip.tracks.length);

            if (clip.tracks.length > 0) {
                const firstTrack = clip.tracks[0];
                console.log('First track name:', firstTrack.name);
                console.log('First track times (first 5):', firstTrack.times.slice(0, 5));
                console.log('First track times (last 5):', firstTrack.times.slice(-5));
                console.log('Min time:', Math.min(...firstTrack.times));
                console.log('Max time:', Math.max(...firstTrack.times));
            }

            // Normalize all track times to start at 0
            if (minTime > 0.001) { // Only normalize if there's a significant offset
                console.log('ENEMY: Normalizing animation - removing offset of:', minTime);
                clip.tracks.forEach(track => {
                    for (let i = 0; i < track.times.length; i++) {
                        track.times[i] -= minTime;
                    }
                });
                // Recalculate duration
                clip.duration = clip.tracks.reduce((max, track) => {
                    return Math.max(max, track.times[track.times.length - 1]);
                }, 0);
                console.log('ENEMY: New duration after normalization:', clip.duration);
            }

            // === RALPH'S FIX: Remove the Hips position track that causes flashing ===
            console.log('ENEMY: Filtering animation tracks...');
            const originalTrackCount = clip.tracks.length;
            clip.tracks = clip.tracks.filter(track => {
                // Remove ONLY the root Hips position track
                if (track.name === 'mixamorigHips.position') {
                    console.log('ENEMY: ❌ Removing:', track.name);
                    return false;
                }
                return true; // Keep all rotation tracks
            });
            console.log(`ENEMY: Removed ${originalTrackCount - clip.tracks.length} track(s), kept ${clip.tracks.length}`);

            // === SOLUTION: Try using original clip without subclip first ===
            const action = enemyMixer.clipAction(clip);
            action.setLoop(THREE.LoopRepeat, Infinity);
            action.clampWhenFinished = false;
            action.timeScale = 1.0; // Normal speed
            action.reset();
            action.play();
            console.log('ENEMY: Animation playing with normalized clip, duration:', clip.duration);
        }

        console.log('Enemy character loaded');
    }, undefined, (error) => {
        console.error('Error loading enemy FBX:', error);
        // Fallback to simple cube
        createFallbackEnemy();
    });
}

function createFallbackEnemy() {
    const geometry = new THREE.BoxGeometry(1, 2, 1);
    const material = new THREE.MeshLambertMaterial({ color: 0xef5350 });
    enemyModel = new THREE.Mesh(geometry, material);
    enemyModel.position.set(0, 1.0, -15);
    enemyModel.castShadow = true;
    scene.add(enemyModel);
}

// ============================================================================
// SHOOTING GAME - OFFICER CHARACTER
// ============================================================================

// Officer animation actions
let officerActions = {
    idle: null,
    run: null,
    shoot: null,
    current: null
};

// Submachine gun model
let subMachineGun = null;
let muzzleFlash = null; // Yellow flash at gun tip
let smokeParticles = []; // Smoke particles from gun
let bulletCasings = []; // Shell casings on ground
let flashColorToggle = true; // Alternate between yellow and white

// Gun rotation controls for dashboard
// Settings for different facing directions
const GunConfigs = {
    // Officer facing RIGHT (positive X direction, 90°)
    right: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    },
    // Officer facing LEFT (negative X direction, 270°/-90°)
    left: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    },
    // Officer facing FORWARD/UP (negative Z direction, 0°)
    forward: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    },
    // Officer facing BACKWARD/DOWN (positive Z direction, 180°)
    backward: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    }
};

const GunControls = {
    rotationX: -10 * Math.PI / 180,  // -10°
    rotationY: 180 * Math.PI / 180,   // 180°
    rotationZ: 85 * Math.PI / 180,    // 85°
    positionX: -15.0,
    positionY: 31.5,
    positionZ: 1.0,
    scale: 0.25,
    currentDirection: 'right',  // Track current direction

    updateForDirection(direction) {
        // Update gun settings based on officer's facing direction
        if (direction !== this.currentDirection) {
            const config = GunConfigs[direction];
            if (config) {
                this.rotationX = config.rotationX;
                this.rotationY = config.rotationY;
                this.rotationZ = config.rotationZ;
                this.positionX = config.positionX;
                this.positionY = config.positionY;
                this.positionZ = config.positionZ;
                this.scale = config.scale;
                this.currentDirection = direction;
                console.log('Gun config switched to:', direction);
            }
        }
    },

    applyRotation() {
        if (subMachineGun) {
            subMachineGun.rotation.set(this.rotationX, this.rotationY, this.rotationZ);
            subMachineGun.position.set(this.positionX, this.positionY, this.positionZ);
            subMachineGun.scale.set(this.scale, this.scale, this.scale);
        }
    },

    reset() {
        this.rotationX = -10 * Math.PI / 180;  // -10°
        this.rotationY = 180 * Math.PI / 180;   // 180°
        this.rotationZ = 85 * Math.PI / 180;    // 85°
        this.positionX = -15.0;
        this.positionY = 31.5;
        this.positionZ = 1.0;
        this.scale = 0.25;
        this.applyRotation();
    }
};

function loadSubMachineGun() {
    if (!shooterModel) {
        console.error('Cannot load gun: officer model not loaded yet');
        return;
    }

    const loader = new GLTFLoader();

    console.log('Loading M4A1 rifle...');

    loader.load(
        'm4a1/scene.gltf',
        // onLoad
        (gltf) => {
            console.log('M4A1 loaded successfully');

            subMachineGun = gltf.scene;

            // Scale the gun much smaller to match officer hands
            subMachineGun.scale.set(0.15, 0.15, 0.15);

            // Enable shadows on all meshes
            subMachineGun.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Find the right hand bone
            let rightHand = null;
            shooterModel.traverse((child) => {
                if (child.isBone && child.name === 'mixamorigRightHand') {
                    rightHand = child;
                    console.log('Found right hand bone:', child.name);
                }
            });

            if (rightHand) {
                // Attach gun to right hand bone
                rightHand.add(subMachineGun);

                // Position and rotation - these values worked before
                subMachineGun.position.set(0, -2, -5);
                subMachineGun.rotation.set(-Math.PI / 2, 0, 0);

                console.log('M4A1 attached to right hand');
            } else {
                console.warn('Right hand bone not found, adding gun to officer model');
                shooterModel.add(subMachineGun);
                subMachineGun.position.set(0.5, 1.2, 0);
            }

            // Create muzzle flash - bright sphere at gun barrel tip
            const flashGeometry = new THREE.SphereGeometry(3, 12, 12);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // Bright yellow (will alternate with white)
                transparent: true,
                opacity: 1.0
            });
            muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);

            // Position at gun barrel tip (nozzle)
            muzzleFlash.position.set(0, 0, -40); // Forward along gun barrel at nozzle

            // Add bright point light for glow effect
            const flashLight = new THREE.PointLight(0xffff00, 5, 80);
            muzzleFlash.add(flashLight);

            // Attach to gun
            subMachineGun.add(muzzleFlash);

            // Start invisible
            muzzleFlash.visible = false;

            console.log('Muzzle flash created at barrel tip');

        },
        // onProgress
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                console.log('M4A1 loading: ' + percent + '%');
            }
        },
        // onError
        (error) => {
            console.error('Error loading M4A1:', error);
        }
    );
}

function loadOfficerCharacter() {
    const loader = new FBXLoader();

    console.log('Loading Officer character for Maze mode...');

    // Load the Officer model first
    loader.load('Officer.fbx', (fbx) => {
        shooterModel = fbx;
        shooterModel.scale.set(0.01, 0.01, 0.01);
        // Position will be set after tunnel loads - use temp position for now
        shooterModel.position.set(0, 1.0, 0);
        shooterModel.rotation.y = Math.PI; // Face forward down the tunnel (toward positive Z)

        console.log('Officer loaded at position:', shooterModel.position.x, shooterModel.position.z);

        // Keep original textures
        shooterModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        scene.add(shooterModel);

        // Expose shooterModel to window for debugging/testing
        window.shooterModel = shooterModel;

        // RALPH FIX: If tunnel already loaded, position officer inside it now
        if (urbanEnvironment) {
            console.log('Officer loaded AFTER tunnel - positioning now...');

            // Use configured starting position
            const startPos = LEVEL_CONFIG.ANIMATION_TESTING_START;

            shooterModel.position.set(startPos.x, startPos.y, startPos.z);
            shooterModel.rotation.y = startPos.rotation;

            camera.position.set(startPos.x, startPos.y + 3, startPos.z - 8);
            camera.lookAt(startPos.x, startPos.y + 0.5, startPos.z + 10);

            console.log('Officer positioned at STARTING POINT:', startPos.description);
            console.log('Position - X=' + startPos.x.toFixed(2) + ', Y=' + startPos.y.toFixed(2) + ', Z=' + startPos.z.toFixed(2));
        } else {
            console.log('Officer loaded BEFORE tunnel - will be positioned when tunnel loads');
        }

        // Load submachine gun and attach to hand
        loadSubMachineGun();

        // Setup animation mixer
        shooterMixer = new THREE.AnimationMixer(shooterModel);

        // Load multiple animations
        let animationsLoaded = 0;
        const totalAnimations = 3; // run, idle, shoot

        function checkAllAnimationsLoaded() {
            animationsLoaded++;
            if (animationsLoaded === totalAnimations) {
                // Start with idle animation
                if (officerActions.idle) {
                    officerActions.idle.play();
                    officerActions.current = 'idle';
                }

                // Initialize maze controller
                MazeController.init();
                console.log('Officer ready with animations!');
            }
        }

        // Load Rifle Run animation
        loader.load('Rifle Run.fbx', (animFbx) => {
            if (animFbx.animations && animFbx.animations.length > 0) {
                const clip = animFbx.animations[0];

                console.log('=== OFFICER RUN Animation ===');
                console.log('Duration:', clip.duration);

                // Remove position track
                clip.tracks = clip.tracks.filter(track => track.name !== 'mixamorigHips.position');

                // Create action
                officerActions.run = shooterMixer.clipAction(clip);
                officerActions.run.setLoop(THREE.LoopRepeat, Infinity);

                console.log('Run animation loaded');
            }
            checkAllAnimationsLoaded();
        }, undefined, (error) => {
            console.error('Error loading Rifle Run:', error);
            checkAllAnimationsLoaded();
        });

        // Load Rifle Idle animation
        loader.load('Rifle Idle.fbx', (animFbx) => {
            if (animFbx.animations && animFbx.animations.length > 0) {
                const clip = animFbx.animations[0];

                console.log('=== OFFICER IDLE Animation ===');
                console.log('Duration:', clip.duration);

                // Remove position track
                clip.tracks = clip.tracks.filter(track => track.name !== 'mixamorigHips.position');

                // Create action
                officerActions.idle = shooterMixer.clipAction(clip);
                officerActions.idle.setLoop(THREE.LoopRepeat, Infinity);

                console.log('Idle animation loaded');
            }
            checkAllAnimationsLoaded();
        }, undefined, (error) => {
            console.error('Error loading Rifle Idle:', error);
            checkAllAnimationsLoaded();
        });

        // Load Shooting animation
        loader.load('Rifle Shooting.fbx', (animFbx) => {
            if (animFbx.animations && animFbx.animations.length > 0) {
                const clip = animFbx.animations[0];

                console.log('=== OFFICER SHOOT Animation ===');
                console.log('Duration:', clip.duration);

                // Remove position track
                clip.tracks = clip.tracks.filter(track => track.name !== 'mixamorigHips.position');

                // Create action
                officerActions.shoot = shooterMixer.clipAction(clip);
                officerActions.shoot.setLoop(THREE.LoopOnce, 1);
                officerActions.shoot.clampWhenFinished = true;

                console.log('Shoot animation loaded');
            }
            checkAllAnimationsLoaded();
        }, undefined, (error) => {
            console.error('Error loading Rifle Shooting:', error);
            checkAllAnimationsLoaded();
        });

    }, undefined, (error) => {
        console.error('Error loading Officer model:', error);

        // Create a fallback character
        const geometry = new THREE.CapsuleGeometry(0.4, 1.2, 8, 16);
        const material = new THREE.MeshLambertMaterial({ color: 0x2196f3 });
        shooterModel = new THREE.Mesh(geometry, material);
        shooterModel.position.set(TILE_SIZE * 1.5, 1.0, TILE_SIZE * 1.5);
        shooterModel.castShadow = true;
        scene.add(shooterModel);

        // Initialize maze controller with fallback
        MazeController.init();

        console.log('Created fallback character (Officer load failed)');
    });
}

// ============================================================================
// MAZE BUILDING
// ============================================================================

function buildTestingGround() {
    console.log('Building testing ground...');

    // Clear any existing elements
    mazeWalls.forEach(wall => scene.remove(wall));
    mazeWalls = [];
    if (exitMarker) scene.remove(exitMarker);

    // Skip creating test floor - tunnel environment has its own floor
    console.log('Skipping test floor - using tunnel road surface');

    // Load urban environment
    loadUrbanEnvironment();
}

// ============================================================================
// URBAN ENVIRONMENT LOADING
// ============================================================================

function setupUrbanLighting() {
    console.log('Setting up tunnel lighting...');

    // PITCH BLACK - Makes outside of tunnel invisible
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 10, 50); // Black fog for areas outside tunnel

    // BRIGHT DAYLIGHT LIGHTING
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfffacd, 2.0);
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -200;
    sunLight.shadow.camera.right = 200;
    sunLight.shadow.camera.top = 200;
    sunLight.shadow.camera.bottom = -200;
    scene.add(sunLight);

    // RALPH: Floor will be created AFTER tunnel loads to match exact tunnel position

    console.log('Tunnel lighting setup complete');
}

function loadUrbanEnvironment() {
    console.log('Loading tunnel road environment...');

    // Setup atmospheric lighting first
    setupUrbanLighting();

    const loader = new GLTFLoader();

    loader.load(
        'tunnel-road.glb',
        // onLoad
        (gltf) => {
            urbanEnvironment = gltf.scene;

            // STEP TRACKER DATA:
            // User walked X: -38.11 to +10.93 (about 49 units)
            // User walked Z: -208.07 to +189.46 (about 397 units)
            // User's starting position: X: -29.05, Z: -200.28
            //
            // Original scale (80, 80, 15) was too small:
            //   - Visual walls around X=+/-3 didn't contain user at X=-29
            //   - Z from -198 to +198 put user at Z=-200 just outside
            //
            // ⭐ PERFECT SIZE - User confirmed 2026-01-24 at 17:37
            // DO NOT CHANGE THIS SCALE - This is the ideal tunnel size
            urbanEnvironment.scale.set(100, 100, 100);  // PERFECT TUNNEL SIZE
            urbanEnvironment.position.set(-13.5, 0, 0); // Shift left to center user's asymmetric path

            // Rotate on Y-axis to change from horizontal to extending forward/backward
            urbanEnvironment.rotation.x = 0;
            urbanEnvironment.rotation.y = Math.PI / 2; // Rotate 90 degrees to extend along Z-axis
            urbanEnvironment.rotation.z = 0;

            console.log('Tunnel positioned at:', urbanEnvironment.position);
            console.log('Tunnel rotation:', urbanEnvironment.rotation);
            console.log('Tunnel scale:', urbanEnvironment.scale);

            // RALPH: Remove built-in floor texture
            console.log('=== TUNNEL MODEL MESH ANALYSIS ===');
            const meshesToRemove = [];
            urbanEnvironment.traverse((child) => {
                if (child.isMesh) {
                    const bbox = new THREE.Box3().setFromObject(child);
                    const size = bbox.getSize(new THREE.Vector3());
                    const center = bbox.getCenter(new THREE.Vector3());

                    console.log('MESH:', child.name || 'unnamed');
                    console.log('  Type:', child.type);
                    console.log('  Size:', size.x.toFixed(2), 'x', size.y.toFixed(2), 'x', size.z.toFixed(2));
                    console.log('  Position:', child.position.x.toFixed(2), child.position.y.toFixed(2), child.position.z.toFixed(2));
                    console.log('  Center:', center.x.toFixed(2), center.y.toFixed(2), center.z.toFixed(2));
                    console.log('  Material:', child.material?.type || 'none');

                    // Crop out structures outside tunnel bounds
                    // Based on step tracker data: user walks X: -38 to +11
                    // Collision walls are at X: -43.5 (left) and +16.5 (right)
                    // Keep only structures within playable tunnel: X: -45 to +18
                    const minX = -45;
                    const maxX = 18;

                    if (center.x > maxX) {
                        console.log('  ❌ CROPPING RIGHT - outside bounds (X:', center.x.toFixed(2), '> maxX:', maxX, ')');
                        meshesToRemove.push(child);
                        return;
                    }

                    if (center.x < minX) {
                        console.log('  ❌ CROPPING LEFT - outside bounds (X:', center.x.toFixed(2), '< minX:', minX, ')');
                        meshesToRemove.push(child);
                        return;
                    }

                    console.log('  ✅ KEEPING');
                    console.log('---');

                    // TUNNEL VISIBILITY FIX: Keep original texture but enable DoubleSide
                    if (child.material) {
                        // Clone material to avoid modifying shared material
                        child.material = child.material.clone();
                        child.material.side = THREE.DoubleSide;  // Render both sides for visibility
                        console.log('Tunnel material: kept original texture, enabled DoubleSide for:', child.name);
                    }

                    // Setup shadows
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Remove cropped meshes
            console.log('=== CROPPING RESULTS ===');
            console.log('Total meshes analyzed:', meshesToRemove.length + ' removed');
            console.log('Cropping bounds: X from -45 to +18');
            meshesToRemove.forEach(mesh => {
                if (mesh.parent) {
                    mesh.parent.remove(mesh);
                    console.log('Removed:', mesh.name || 'unnamed');
                }
            });
            console.log('✅ Cropping complete:', meshesToRemove.length, 'meshes removed');

            scene.add(urbanEnvironment);

            console.log('Tunnel road loaded');

            // RALPH: NARROW floor strip - like a red carpet runway
            const box = new THREE.Box3().setFromObject(urbanEnvironment);

            // FIX: Adjust tunnel Y position so its floor is at Y=0
            // The tunnel model's geometry has its floor at some positive Y value
            // which gets scaled by 800, putting the tunnel way above the character
            const tunnelMinY = box.min.y;
            const tunnelMaxY = box.max.y;
            console.log('=== TUNNEL Y BOUNDS BEFORE ADJUSTMENT ===');
            console.log('Tunnel min Y (floor):', tunnelMinY.toFixed(2));
            console.log('Tunnel max Y (ceiling):', tunnelMaxY.toFixed(2));
            console.log('Tunnel height:', (tunnelMaxY - tunnelMinY).toFixed(2));

            // Move the tunnel down so its floor (minY) is at Y=0
            // This puts the character INSIDE the tunnel instead of below it
            urbanEnvironment.position.y = -tunnelMinY;
            console.log('Adjusted tunnel Y position to:', urbanEnvironment.position.y.toFixed(2));

            // Recompute bounding box after Y adjustment
            const boxAfter = new THREE.Box3().setFromObject(urbanEnvironment);
            console.log('=== TUNNEL Y BOUNDS AFTER ADJUSTMENT ===');
            console.log('Tunnel min Y (floor):', boxAfter.min.y.toFixed(2));
            console.log('Tunnel max Y (ceiling):', boxAfter.max.y.toFixed(2));

            const tunnelMinZ = boxAfter.min.z;
            const tunnelMaxZ = boxAfter.max.z;
            const tunnelLength = tunnelMaxZ - tunnelMinZ;
            const tunnelCenterZ = (tunnelMinZ + tunnelMaxZ) / 2;

            // ⭐ STAGE 2: OLD Cylindrical collision wall - DISABLED
            // Now using CollisionSystem with 3 versions: V0 (Original), V1 (BVH), V2 (Raycasting)
            console.log('🎯 STAGE 2 SKIPPED: Using CollisionSystem instead of old red cylinder');

            // OLD CODE - REMOVED (was creating visible red cylinder)
            // const wallMaterial = new THREE.MeshBasicMaterial({
            //     color: 0xff0000,
            //     transparent: true,
            //     opacity: 0.3,
            //     side: THREE.DoubleSide
            // });
            // const tunnelRadius = 30;
            // const tunnelCollisionGeometry = new THREE.CylinderGeometry(...);
            // tunnelCollisionGeometry.rotateX(Math.PI / 2);
            // const tunnelCollisionWall = new THREE.Mesh(tunnelCollisionGeometry, wallMaterial);
            // tunnelCollisionWall.position.set(0, 6, 0);
            // scene.add(tunnelCollisionWall);

            console.log('✅ Old red collision wall DISABLED - using invisible CollisionSystem');

            // Calculate bounding box for collision (using adjusted box)
            const size = boxAfter.getSize(new THREE.Vector3());
            const center = boxAfter.getCenter(new THREE.Vector3());

            console.log('Tunnel bounds:', {
                center: { x: center.x.toFixed(2), y: center.y.toFixed(2), z: center.z.toFixed(2) },
                size: { x: size.x.toFixed(2), y: size.y.toFixed(2), z: size.z.toFixed(2) }
            });

            // Calculate tunnel start and end positions
            const tunnelStart = center.z - (size.z / 2);
            const tunnelEnd = center.z + (size.z / 2);
            console.log('Tunnel extends from Z=' + tunnelStart.toFixed(2) + ' to Z=' + tunnelEnd.toFixed(2));

            // Reposition officer near the EXIT end but still fully enclosed
            if (shooterModel) {
                // Calculate from bounding box (this worked before)
                const box = new THREE.Box3().setFromObject(urbanEnvironment);
                const tunnelMinZ = box.min.z;
                const tunnelMaxZ = box.max.z;
                const tunnelLength = tunnelMaxZ - tunnelMinZ;

                console.log('=== TUNNEL DIMENSIONS ===');
                console.log('Tunnel MinZ (ENTRANCE):', tunnelMinZ.toFixed(2));
                console.log('Tunnel MaxZ (EXIT):', tunnelMaxZ.toFixed(2));
                console.log('Tunnel Length:', tunnelLength.toFixed(2), 'units');

                // Use configured starting position for Animation Testing mode
                const startPos = LEVEL_CONFIG.ANIMATION_TESTING_START;

                console.log('=== STARTING POSITION ===');
                console.log('Using saved starting point:', startPos.description);
                console.log('Position - X:', startPos.x.toFixed(2), 'Y:', startPos.y.toFixed(2), 'Z:', startPos.z.toFixed(2));

                shooterModel.position.set(startPos.x, startPos.y, startPos.z);
                shooterModel.rotation.y = startPos.rotation;

                console.log('Officer ACTUAL position:', {
                    x: shooterModel.position.x.toFixed(2),
                    y: shooterModel.position.y.toFixed(2),
                    z: shooterModel.position.z.toFixed(2)
                });

                // Camera BEHIND officer (lower Z = behind when facing positive Z)
                // TUNNEL VISIBILITY FIX: Lower camera height to see walls on sides better
                camera.position.set(startPos.x, startPos.y + 1.5, startPos.z - 6);
                camera.lookAt(startPos.x, startPos.y + 0.5, startPos.z + 20);

                console.log('Camera position:', {
                    x: camera.position.x.toFixed(2),
                    y: camera.position.y.toFixed(2),
                    z: camera.position.z.toFixed(2)
                });
                console.log('Camera looking at (toward exit):', {
                    x: startPos.x.toFixed(2),
                    y: (startPos.y + 0.5).toFixed(2),
                    z: (startPos.z + 10).toFixed(2)
                });
            } else {
                console.log('WARNING: Officer not loaded yet when tunnel finished loading');
            }

            // Create collision areas for the tunnel
            createTunnelColliders();

            // Initialize CollisionSystem with tunnel mesh
            CollisionSystem.init(urbanEnvironment);

            // Load car obstacles
            loadPorscheCar();
            loadBMWM8Car();
            loadBMW_X6M_Router();
            loadVW_TCross_Router();

            // Add distance markers so user can see progress
            // addTunnelMarkers(tunnelStart, tunnelEnd);
        },
        // onProgress
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                console.log('Tunnel road loading: ' + percent + '%');
            }
        },
        // onError
        (error) => {
            console.error('Error loading tunnel road:', error);
        }
    );
}

// ============================================================================
// PORSCHE CAR LOADING
// ============================================================================

let porscheCar = null;

function loadPorscheCar() {
    console.log('Loading Porsche 911 Carrera 4S...');

    const loader = new GLTFLoader();

    loader.load(
        'porsche.glb',
        // onLoad
        (gltf) => {
            porscheCar = gltf.scene;

            // Position at user's current location: X: -45.07, Z: -213.23
            // Y: 1.5 to sit on road surface (was sinking at Y: 0)
            porscheCar.position.set(-45.07, 1.5, -213.23);

            // Scale the car appropriately (adjust if needed)
            porscheCar.scale.set(1.5, 1.5, 1.5);

            // Rotate to face forward (toward positive Z)
            porscheCar.rotation.y = 0;

            // Add to scene
            scene.add(porscheCar);

            // Enable shadows
            porscheCar.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Add collision box for the car
            // Porsche 911 is roughly 4.5m long, 1.8m wide, 1.3m tall
            const carLength = 6.75;  // 4.5m * 1.5 scale
            const carWidth = 2.7;    // 1.8m * 1.5 scale
            const carHeight = 2.0;   // 1.3m * 1.5 scale

            addCollider(
                -45.07,           // X position (user's current X)
                -213.23,          // Z position (user's current Z)
                carWidth,         // Width (perpendicular to Z)
                carLength,        // Depth (along Z axis)
                carHeight,        // Height
                'Porsche 911 Carrera 4S',
                0                 // Rotation (facing forward)
            );

            console.log('✅ Porsche 911 loaded at X: -45.07, Z: -213.23 with collision');
        },
        // onProgress
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                console.log('Porsche loading: ' + percent + '%');
            }
        },
        // onError
        (error) => {
            console.error('Error loading Porsche:', error);
        }
    );
}

// ============================================================================
// HAZARD LIGHTS SYSTEM - For all cars
// ============================================================================

let hazardLights = []; // Array to store all hazard light objects
let hazardLightTimer = 0;
const HAZARD_FLASH_SPEED = 0.5; // Flash every 0.5 seconds

function addHazardLightsToCar(carObject, carName) {
    if (!carObject) {
        console.error('Cannot add hazard lights - car object is null');
        return;
    }

    console.log('🔍 Finding light meshes in ' + carName);

    const carLights = {
        left: [],
        right: []
    };

    // Search for light-related meshes in the car model
    const lightMeshes = [];
    carObject.traverse((child) => {
        if (child.isMesh) {
            const name = child.name.toLowerCase();
            // Look for meshes with "light", "lamp", "headlight", "taillight", "brake", "signal" in name
            if (name.includes('light') || name.includes('lamp') || name.includes('head') ||
                name.includes('tail') || name.includes('brake') || name.includes('signal') ||
                name.includes('indicator') || name.includes('blinker')) {
                console.log('  Found light mesh:', child.name, 'pos:', child.position);
                lightMeshes.push(child);
            }
        }
    });

    if (lightMeshes.length === 0) {
        console.log('⚠️ No light meshes found by name. Searching by position...');

        // Get car bounding box to find front/rear
        const box = new THREE.Box3().setFromObject(carObject);
        const size = new THREE.Vector3();
        box.getSize(size);

        // Find meshes at the front and rear corners (likely to be lights)
        carObject.traverse((child) => {
            if (child.isMesh && child.material) {
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);

                // Check if mesh is at edges (potential light location)
                const localPos = carObject.worldToLocal(worldPos.clone());
                const atFront = localPos.z > size.z * 0.3;
                const atRear = localPos.z < -size.z * 0.3;
                const atSide = Math.abs(localPos.x) > size.x * 0.3;

                if ((atFront || atRear) && atSide) {
                    console.log('  Found edge mesh (potential light):', child.name, 'local pos:', localPos);
                    lightMeshes.push(child);
                }
            }
        });
    }

    // Create hazard light effect for found meshes
    lightMeshes.forEach((mesh, index) => {
        const worldPos = new THREE.Vector3();
        mesh.getWorldPosition(worldPos);
        const localPos = carObject.worldToLocal(worldPos.clone());

        // Determine if it's left or right side based on X position
        const side = localPos.x < 0 ? 'left' : 'right';

        // Store original material
        const originalMaterial = mesh.material.clone();

        // Create orange hazard material
        const hazardMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            emissive: 0xff6600,
            emissiveIntensity: 1
        });

        // Create point light at mesh position
        const pointLight = new THREE.PointLight(0xff6600, 0, 10);
        pointLight.position.copy(mesh.position);
        mesh.add(pointLight);

        carLights[side].push({
            mesh: mesh,
            originalMaterial: originalMaterial,
            hazardMaterial: hazardMaterial,
            light: pointLight,
            name: mesh.name
        });

        console.log('  ✅ Added hazard to mesh:', mesh.name, 'side:', side);
    });

    if (carLights.left.length === 0 && carLights.right.length === 0) {
        console.error('❌ No suitable light meshes found for ' + carName);
        return;
    }

    // Store car lights in global array
    hazardLights.push({
        carName: carName,
        carObject: carObject,
        lights: carLights
    });

    console.log('✅ Added hazard lights to ' + carName + ' (' + (carLights.left.length + carLights.right.length) + ' meshes)');
}

function updateHazardLights(delta) {
    hazardLightTimer += delta;

    // Toggle lights every HAZARD_FLASH_SPEED seconds (alternate left-right pattern)
    if (hazardLightTimer >= HAZARD_FLASH_SPEED) {
        hazardLightTimer = 0;

        hazardLights.forEach(carLightSet => {
            // Determine which side to light up
            const leftOn = Math.floor(Date.now() / 500) % 2 === 0; // Alternate every 500ms

            // Turn on left side meshes, turn off right side (or vice versa)
            carLightSet.lights.left.forEach(lightObj => {
                if (leftOn) {
                    // Switch to orange hazard material
                    lightObj.mesh.material = lightObj.hazardMaterial;
                    lightObj.light.intensity = 5;
                } else {
                    // Switch back to original material
                    lightObj.mesh.material = lightObj.originalMaterial;
                    lightObj.light.intensity = 0;
                }
            });

            carLightSet.lights.right.forEach(lightObj => {
                if (!leftOn) {
                    // Switch to orange hazard material
                    lightObj.mesh.material = lightObj.hazardMaterial;
                    lightObj.light.intensity = 5;
                } else {
                    // Switch back to original material
                    lightObj.mesh.material = lightObj.originalMaterial;
                    lightObj.light.intensity = 0;
                }
            });
        });
    }
}


// ============================================================================
// BMW M8 COUPE LOADING - 10 VERSIONS FOR TESTING
// ============================================================================

let bmwM8Car = null;

function loadBMWM8Car() {
    // Check URL parameter for BMW version (?bmw=1, ?bmw=2, etc.)
    const urlParams = new URLSearchParams(window.location.search);
    const bmwVersion = parseInt(urlParams.get('bmw')) || 0;

    console.log('🚗 Loading BMW M8 Coupe - Version ' + bmwVersion);

    // Route to appropriate version
    const box = new THREE.Box3().setFromObject(carObject);
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    box.getSize(size);
    box.getCenter(center);

    // Find tire meshes in the car model
    const tires = {
        frontLeft: null,
        frontRight: null,
        rearLeft: null,
        rearRight: null
    };

    // Search for wheel/tire meshes
    carObject.traverse((child) => {
        if (child.isMesh) {
            const name = child.name.toLowerCase();
            if (name.includes('wheel') || name.includes('tire') || name.includes('rim')) {
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);
                const localPos = carObject.worldToLocal(worldPos.clone());

                // Determine which tire based on position
                const isFront = localPos.z > 0;
                const isLeft = localPos.x < 0;

                if (isFront && isLeft) tires.frontLeft = child;
                else if (isFront && !isLeft) tires.frontRight = child;
                else if (!isFront && isLeft) tires.rearLeft = child;
                else if (!isFront && !isLeft) tires.rearRight = child;
            }
        }
    });

    carDamageStates[carName] = {
        carObject: carObject,
        carName: carName,
        hitCount: 0,
        damageLevel: 'none', // none, light, medium, heavy
        tires: tires,
        poppedTires: {
            frontLeft: false,
            frontRight: false,
            rearLeft: false,
            rearRight: false
        },
        originalRotation: carObject.rotation.clone(),
        originalPosition: carObject.position.clone(),
        enginePosition: new THREE.Vector3(
            center.x,
            center.y + size.y * 0.3, // Slightly above center (engine area)
            center.z + size.z * 0.3   // Toward front of car
        ),
        boundingBox: box,
        size: size,
        isOnFire: false,
        smokeIntensity: 0,
        lastSmokeTime: 0,
        lastFireTime: 0
    };

    console.log('🚗 Initialized damage state for ' + carName);
    console.log('  🛞 Tires found: FL=' + !!tires.frontLeft + ', FR=' + !!tires.frontRight +
                ', RL=' + !!tires.rearLeft + ', RR=' + !!tires.rearRight);
    console.log('  📦 Bounding box size:', size);
    console.log('  🎯 Damage tracking ACTIVE for ' + carName);
}

// Check if a bullet hits a car and process damage
function checkBulletCarCollision(bullet, carName, carState) {
    if (!carState || !carState.carObject) return false;

    // Get bullet position
    const bulletPos = bullet.position.clone();

    // Check if bullet is within car's bounding box (expanded slightly for hit detection)
    const box = new THREE.Box3().setFromObject(carState.carObject);
    box.expandByScalar(0.5); // Slightly larger hitbox for better detection

    if (box.containsPoint(bulletPos)) {
        // Hit detected!
        processBulletHit(carName, carState, bulletPos);
        return true;
    }

    return false;
}

// Process a bullet hit on a car
function processBulletHit(carName, carState, hitPosition) {
    carState.hitCount++;
    console.log('💥 HIT! ' + carName + ' total hits: ' + carState.hitCount);

    // Update damage level
    if (carState.hitCount >= DAMAGE_THRESHOLDS.HEAVY) {
        if (carState.damageLevel !== 'heavy') {
            carState.damageLevel = 'heavy';
            carState.isOnFire = true;
            carState.smokeIntensity = 1.0;
            console.log('🔥 ' + carName + ' is heavily damaged and ON FIRE! (' + carState.hitCount + ' hits)');
        }
    } else if (carState.hitCount >= DAMAGE_THRESHOLDS.MEDIUM) {
        if (carState.damageLevel !== 'medium') {
            carState.damageLevel = 'medium';
            carState.smokeIntensity = 0.6;
            console.log('💨 ' + carName + ' has medium damage - heavy smoke! (' + carState.hitCount + ' hits)');
        }
    } else if (carState.hitCount >= DAMAGE_THRESHOLDS.LIGHT) {
        if (carState.damageLevel !== 'light') {
            carState.damageLevel = 'light';
            carState.smokeIntensity = 0.3;
            console.log('💨 ' + carName + ' has light damage - starting to smoke! (' + carState.hitCount + ' hits)');
        }
    }

    // Check for tire hit
    checkTireHit(carName, carState, hitPosition);

    // Create impact spark effect
    createImpactSpark(hitPosition);
}

// Check if the hit was on a tire
function checkTireHit(carName, carState, hitPosition) {
    const carObject = carState.carObject;
    const localHitPos = carObject.worldToLocal(hitPosition.clone());

    // Calculate tire positions based on car size
    const size = carState.size;
    const tireRadius = size.y * 0.15; // Approximate tire radius

    // Define tire center positions (local coordinates)
    const tirePositions = {
        frontLeft: new THREE.Vector3(-size.x * 0.35, tireRadius, size.z * 0.3),
        frontRight: new THREE.Vector3(size.x * 0.35, tireRadius, size.z * 0.3),
        rearLeft: new THREE.Vector3(-size.x * 0.35, tireRadius, -size.z * 0.3),
        rearRight: new THREE.Vector3(size.x * 0.35, tireRadius, -size.z * 0.3)
    };

    // Check distance to each tire
    const hitThreshold = tireRadius * 2; // Hit detection radius

    for (const [tireName, tirePos] of Object.entries(tirePositions)) {
        const distance = localHitPos.distanceTo(tirePos);

        if (distance < hitThreshold && !carState.poppedTires[tireName]) {
            // Pop this tire!
            popTire(carName, carState, tireName);
            break; // Only pop one tire per hit
        }
    }
}

// Pop a tire and apply visual effects
function popTire(carName, carState, tireName) {
    carState.poppedTires[tireName] = true;
    console.log(carName + ' - ' + tireName + ' tire POPPED!');

    // Create tire pop effect (burst of particles)
    createTirePopEffect(carState, tireName);

    // Apply tilt to car based on which tires are popped
    applyTireTilt(carState);
}

// Create visual effect for tire pop
function createTirePopEffect(carState, tireName) {
    const carObject = carState.carObject;
    const size = carState.size;

    // Get tire position
    let tireLocalPos;
    switch(tireName) {
        case 'frontLeft':
            tireLocalPos = new THREE.Vector3(-size.x * 0.35, size.y * 0.15, size.z * 0.3);
            break;
        case 'frontRight':
            tireLocalPos = new THREE.Vector3(size.x * 0.35, size.y * 0.15, size.z * 0.3);
            break;
        case 'rearLeft':
            tireLocalPos = new THREE.Vector3(-size.x * 0.35, size.y * 0.15, -size.z * 0.3);
            break;
        case 'rearRight':
            tireLocalPos = new THREE.Vector3(size.x * 0.35, size.y * 0.15, -size.z * 0.3);
            break;
    }

    // Convert to world position
    const tireWorldPos = carObject.localToWorld(tireLocalPos.clone());

    // Create burst of dark rubber particles
    for (let i = 0; i < 15; i++) {
        const particleGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 4, 4);
        const particleMaterial = new THREE.MeshBasicMaterial({
            color: 0x222222, // Dark rubber color
            transparent: true,
            opacity: 0.9
        });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);

        particle.position.copy(tireWorldPos);

        // Random burst velocity
        particle.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 5,
            Math.random() * 3 + 2, // Upward
            (Math.random() - 0.5) * 5
        );

        particle.userData.lifetime = 0;
        particle.userData.maxLifetime = 1.0 + Math.random() * 0.5;
        particle.userData.type = 'tirePop';

        scene.add(particle);
        carSmokeParticles.push(particle);
    }
}

// Apply tilt to car based on popped tires
function applyTireTilt(carState) {
    const carObject = carState.carObject;
    const poppedTires = carState.poppedTires;

    // Calculate tilt angles
    let tiltX = 0; // Forward/backward tilt
    let tiltZ = 0; // Left/right tilt
    const maxTilt = 0.1; // Maximum tilt in radians (~5.7 degrees)

    // Left/right tilt
    const leftPopped = (poppedTires.frontLeft ? 1 : 0) + (poppedTires.rearLeft ? 1 : 0);
    const rightPopped = (poppedTires.frontRight ? 1 : 0) + (poppedTires.rearRight ? 1 : 0);
    tiltZ = (leftPopped - rightPopped) * maxTilt * 0.5;

    // Forward/backward tilt
    const frontPopped = (poppedTires.frontLeft ? 1 : 0) + (poppedTires.frontRight ? 1 : 0);
    const rearPopped = (poppedTires.rearLeft ? 1 : 0) + (poppedTires.rearRight ? 1 : 0);
    tiltX = (frontPopped - rearPopped) * maxTilt * 0.5;

    // Apply tilt (add to original rotation)
    carObject.rotation.x = carState.originalRotation.x + tiltX;
    carObject.rotation.z = carState.originalRotation.z + tiltZ;

    // Lower the car slightly for each popped tire
    const totalPopped = leftPopped + rightPopped;
    const dropPerTire = 0.1; // How much the car drops per popped tire
    carObject.position.y = carState.originalPosition.y - (totalPopped * dropPerTire);
}

// Create impact spark effect when bullet hits car
function createImpactSpark(hitPosition) {
    // Create small yellow/orange sparks
    for (let i = 0; i < 8; i++) {
        const sparkGeometry = new THREE.SphereGeometry(0.02, 4, 4);
        const sparkMaterial = new THREE.MeshBasicMaterial({
            color: Math.random() > 0.5 ? 0xffff00 : 0xff8800,
            transparent: true,
            opacity: 1.0
        });
        const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);

        spark.position.copy(hitPosition);

        // Fast random velocity
        spark.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 8,
            Math.random() * 4,
            (Math.random() - 0.5) * 8
        );

        spark.userData.lifetime = 0;
        spark.userData.maxLifetime = 0.2 + Math.random() * 0.2;
        spark.userData.type = 'spark';

        scene.add(spark);
        carSmokeParticles.push(spark);
    }
}

// Create smoke particles for damaged car
function createCarSmoke(carState, delta) {
    if (carState.smokeIntensity <= 0) return;

    const now = performance.now();
    const smokeInterval = 100 / carState.smokeIntensity; // More smoke when more damaged

    if (now - carState.lastSmokeTime < smokeInterval) return;
    carState.lastSmokeTime = now;

    const carObject = carState.carObject;

    // Get engine area position (front of car, slightly above center)
    const engineLocalPos = new THREE.Vector3(
        0,
        carState.size.y * 0.5,
        carState.size.z * 0.35
    );
    const engineWorldPos = carObject.localToWorld(engineLocalPos.clone());

    // Smoke color based on damage level
    let smokeColor;
    let smokeSize;
    let numParticles;

    if (carState.damageLevel === 'heavy') {
        smokeColor = 0x222222; // Dark black smoke
        smokeSize = 0.6;
        numParticles = 3;
    } else if (carState.damageLevel === 'medium') {
        smokeColor = 0x444444; // Dark gray smoke
        smokeSize = 0.4;
        numParticles = 2;
    } else {
        smokeColor = 0x888888; // Light gray smoke
        smokeSize = 0.3;
        numParticles = 1;
    }

    // Create smoke particles
    for (let i = 0; i < numParticles; i++) {
        const smokeGeometry = new THREE.SphereGeometry(smokeSize, 8, 8);
        const smokeMaterial = new THREE.MeshBasicMaterial({
            color: smokeColor,
            transparent: true,
            opacity: 0.5 + Math.random() * 0.2
        });
        const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);

        smoke.position.copy(engineWorldPos);
        smoke.position.x += (Math.random() - 0.5) * 0.3;
        smoke.position.z += (Math.random() - 0.5) * 0.3;

        // Smoke rises upward with slight drift
        smoke.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            1.5 + Math.random() * 1.0, // Upward
            (Math.random() - 0.5) * 0.5
        );

        smoke.userData.lifetime = 0;
        smoke.userData.maxLifetime = 2.0 + Math.random() * 1.0;
        smoke.userData.type = 'smoke';
        smoke.userData.initialSize = smokeSize;

        scene.add(smoke);
        carSmokeParticles.push(smoke);
    }
}

// Create fire particles for heavily damaged car
function createCarFire(carState, delta) {
    if (!carState.isOnFire) return;

    const now = performance.now();
    const fireInterval = 50; // Fast fire particle generation

    if (now - carState.lastFireTime < fireInterval) return;
    carState.lastFireTime = now;

    const carObject = carState.carObject;

    // Fire comes from engine area
    const engineLocalPos = new THREE.Vector3(
        0,
        carState.size.y * 0.4,
        carState.size.z * 0.35
    );
    const engineWorldPos = carObject.localToWorld(engineLocalPos.clone());

    // Create fire particles (orange/yellow)
    for (let i = 0; i < 4; i++) {
        // Fire particle
        const fireSize = 0.2 + Math.random() * 0.3;
        const fireGeometry = new THREE.SphereGeometry(fireSize, 6, 6);

        // Random fire color (yellow, orange, red)
        const fireColors = [0xff4400, 0xff6600, 0xff8800, 0xffaa00, 0xffcc00];
        const fireColor = fireColors[Math.floor(Math.random() * fireColors.length)];

        const fireMaterial = new THREE.MeshBasicMaterial({
            color: fireColor,
            transparent: true,
            opacity: 0.8 + Math.random() * 0.2
        });
        const fire = new THREE.Mesh(fireGeometry, fireMaterial);

        fire.position.copy(engineWorldPos);
        fire.position.x += (Math.random() - 0.5) * 0.5;
        fire.position.z += (Math.random() - 0.5) * 0.5;

        // Fire rises quickly with flickering motion
        fire.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 1.5,
            2.5 + Math.random() * 2.0, // Fast upward
            (Math.random() - 0.5) * 1.5
        );

        fire.userData.lifetime = 0;
        fire.userData.maxLifetime = 0.5 + Math.random() * 0.5;
        fire.userData.type = 'fire';
        fire.userData.initialSize = fireSize;

        scene.add(fire);
        carFireParticles.push(fire);
    }

    // Add point light for fire glow (temporary)
    if (Math.random() > 0.7) { // Don't add light every frame
        const fireLight = new THREE.PointLight(0xff6600, 2, 5);
        fireLight.position.copy(engineWorldPos);
        fireLight.userData.lifetime = 0;
        fireLight.userData.maxLifetime = 0.2;
        fireLight.userData.type = 'fireLight';
        scene.add(fireLight);
        carFireParticles.push(fireLight);
    }
}

// Update all car damage particles
function updateCarDamageParticles(delta) {
    // Update smoke particles
    for (let i = carSmokeParticles.length - 1; i >= 0; i--) {
        const particle = carSmokeParticles[i];
        particle.userData.lifetime += delta;

        const lifeProgress = particle.userData.lifetime / particle.userData.maxLifetime;

        // Move particle
        if (particle.userData.velocity) {
            particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
        }

        // Apply gravity to tire pop particles
        if (particle.userData.type === 'tirePop') {
            particle.userData.velocity.y -= 9.8 * delta;
        }

        // Slow down velocity
        if (particle.userData.velocity) {
            particle.userData.velocity.multiplyScalar(0.98);
        }

        // Smoke expands and fades
        if (particle.userData.type === 'smoke' && particle.material) {
            const newScale = 1 + lifeProgress * 3; // Grow larger
            particle.scale.setScalar(newScale);
            particle.material.opacity = 0.6 * (1 - lifeProgress);
        }

        // Sparks fade quickly
        if (particle.userData.type === 'spark' && particle.material) {
            particle.material.opacity = 1 - lifeProgress;
        }

        // Remove if expired
        if (particle.userData.lifetime >= particle.userData.maxLifetime) {
            scene.remove(particle);
            carSmokeParticles.splice(i, 1);
        }
    }

    // Update fire particles
    for (let i = carFireParticles.length - 1; i >= 0; i--) {
        const particle = carFireParticles[i];
        particle.userData.lifetime += delta;

        const lifeProgress = particle.userData.lifetime / particle.userData.maxLifetime;

        if (particle.userData.type === 'fire') {
            // Move fire particle
            if (particle.userData.velocity) {
                particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
            }

            // Fire shrinks and fades as it rises
            const newScale = (1 - lifeProgress * 0.5);
            particle.scale.setScalar(newScale);
            if (particle.material) {
                particle.material.opacity = 0.9 * (1 - lifeProgress * 0.7);
            }

            // Add flickering motion
            particle.position.x += (Math.random() - 0.5) * delta * 2;
        }

        if (particle.userData.type === 'fireLight' && particle.isLight) {
            // Fade light intensity
            particle.intensity = 2 * (1 - lifeProgress);
        }

        // Remove if expired
        if (particle.userData.lifetime >= particle.userData.maxLifetime) {
            scene.remove(particle);
            carFireParticles.splice(i, 1);
        }
    }
}

// Main update function for car damage system
function updateCarDamageSystem(delta) {
    // Debug: Log system status once
    if (!updateCarDamageSystem.hasLogged) {
        console.log('🔧 Car damage system active');
        console.log('🔧 Tracked cars:', Object.keys(carDamageStates));
        updateCarDamageSystem.hasLogged = true;
    }

    // Check bullet collisions with all cars
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];

        // Check collision with each tracked car
        for (const [carName, carState] of Object.entries(carDamageStates)) {
            if (checkBulletCarCollision(bullet, carName, carState)) {
                // Remove bullet on hit
                scene.remove(bullet);
                bullets.splice(i, 1);
                console.log('🎯 Bullet hit ' + carName + '! Damage: ' + carState.hitCount + '/∞');
                break; // Bullet can only hit one car
            }
        }
    }

    // Update smoke and fire effects for damaged cars
    for (const [carName, carState] of Object.entries(carDamageStates)) {
        if (carState.damageLevel !== 'none') {
            createCarSmoke(carState, delta);
        }
        if (carState.isOnFire) {
            createCarFire(carState, delta);
        }
    }

    // Update particles
    updateCarDamageParticles(delta);
}

// Initialize damage tracking for all cars after they're loaded
function initializeAllCarDamage() {
    if (bmwM8Car) {
        initCarDamageState(bmwM8Car, 'BMW M8 Coupe');
    }
    if (bmwX6M) {
        initCarDamageState(bmwX6M, 'BMW X6M Competition');
    }
    if (vwTCross) {
        initCarDamageState(vwTCross, 'Volkswagen T-Cross');
    }
    console.log('Car damage system initialized for ' + Object.keys(carDamageStates).length + ' cars');
}

// ============================================================================
// BMW M8 COUPE LOADING - 10 VERSIONS FOR TESTING
// ============================================================================

let bmwM8Car = null;

function loadBMWM8Car() {
    // Check URL parameter for BMW version (?bmw=1, ?bmw=2, etc.)
    const urlParams = new URLSearchParams(window.location.search);
    const bmwVersion = parseInt(urlParams.get('bmw')) || 0;

    console.log('🚗 Loading BMW M8 Coupe - Version ' + bmwVersion);

    // Route to appropriate version
    // NOTE: X6M is loaded separately via loadBMW_X6M_Router() - use ?x6m=1 for X6M
    // To load BOTH cars: ?bmw=1&x6m=1
    switch(bmwVersion) {
        case 1: loadBMW_V1_ScaleInvestigation(); break;
        case 2: loadBMW_V2_YPositionFix(); break;
        case 3: loadBMW_V3_TexturesFolder(); break;
        case 4: loadBMW_V4_FlattenHierarchy(); break;
        case 5: loadBMW_V5_SimpleMaterial(); break;
        case 6: loadBMW_V6_RemoveCameras(); break;
        case 7: loadBMW_V7_ForceVisible(); break;
        case 8: loadBMW_V8_NoHelper(); break;
        case 9: loadBMW_V9_ExtremeScale(); break;
        case 10: loadBMW_V10_CenterGeometry(); break;
        default:
            console.log('No BMW M8 version specified (bmw=' + bmwVersion + ')');
            console.log('Use ?bmw=1 through ?bmw=10 for M8 Coupe');
            console.log('Use ?x6m=1 through ?x6m=10 for X6M Competition');
            console.log('For BOTH cars: ?bmw=1&x6m=1');
            // Don't return - let loadBMW_X6M_Router() be called separately
            return;
    }
}

// V1: Scale Investigation - Adjusted to realistic size
function loadBMW_V1_ScaleInvestigation() {
    console.log('V1: BMW M8 with realistic scale');
    console.log('V1: Attempting to load M8 from: 2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb');
    const loader = new GLTFLoader();

    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb',
        // onLoad
        (gltf) => {
            console.log('V1: M8 GLB file loaded successfully!', gltf);
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 0, -191.66); // Y: 0 to place on road surface
        bmwM8Car.scale.set(150, 150, 150); // Slightly larger for better visibility
        scene.add(bmwM8Car);

        // Enable shadows and use original materials (or dark gray if materials missing)
        bmwM8Car.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;

                // Keep original material if it exists and looks good, otherwise use dark gray
                if (child.material) {
                    // Original materials should work now that scale is correct
                    child.material.side = THREE.DoubleSide;
                    child.material.needsUpdate = true;
                } else {
                    // Fallback to realistic dark gray/black car color
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a, // Dark gray/black (realistic BMW color)
                        metalness: 0.8,
                        roughness: 0.2,
                        side: THREE.DoubleSide
                    });
                }
            }
        });

        // Add collision
        addCollider(-31.61, -191.66, 2.87, 7.29, 2.1, 'BMW M8 Coupe', 0);

        // Add hazard lights
        addHazardLightsToCar(bmwM8Car, 'BMW M8 Coupe');

        // Initialize damage system for this car
        initCarDamageState(bmwM8Car, 'BMW M8 Coupe');

        console.log('✅ V1: BMW M8 loaded at realistic scale with original materials');
    },
    // onProgress
    (xhr) => {
        if (xhr.lengthComputable) {
            const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
            console.log('V1: M8 loading progress: ' + percent + '%');
        }
    },
    // onError
    (error) => {
        console.error('❌ M8 V1 Load Error:', error);
        console.error('Error details:', error.message, error.stack);
    });
}

// V2: Y-Position Fix - Test different Y heights
function loadBMW_V2_YPositionFix() {
    console.log('V2: Testing Y Position (Y: 50)');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 50, -191.66); // High in air
        bmwM8Car.scale.set(5, 5, 5);
        scene.add(bmwM8Car);
        bmwM8Car.traverse((child) => {
            if (child.isMesh) child.material = new THREE.MeshLambertMaterial({color: 0x00ff00});
        });
        console.log('✅ V2: BMW loaded at Y: 50');
    });
}

// V3: Load from textures folder path
function loadBMW_V3_TexturesFolder() {
    console.log('V3: Testing with full folder path');
    const loader = new GLTFLoader();
    loader.setPath('2020-bmw-m8-coupe/');
    loader.load('source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(3, 3, 3);
        scene.add(bmwM8Car);
        console.log('✅ V3: BMW loaded with setPath()');
    });
}

// V4: Flatten hierarchy - use first child
function loadBMW_V4_FlattenHierarchy() {
    console.log('V4: Testing flattened hierarchy (first child)');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene.children[0] || gltf.scene;
        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(10, 10, 10);
        scene.add(bmwM8Car);
        bmwM8Car.traverse((child) => {
            if (child.isMesh) child.material = new THREE.MeshBasicMaterial({color: 0xffff00});
        });
        console.log('✅ V4: BMW loaded using children[0]');
    });
}

// V5: Simple Basic Material
function loadBMW_V5_SimpleMaterial() {
    console.log('V5: Testing MeshBasicMaterial (no lighting needed)');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(2, 2, 2);
        scene.add(bmwM8Car);
        bmwM8Car.traverse((child) => {
            if (child.isMesh) {
                child.material = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    side: THREE.DoubleSide
                });
            }
        });
        console.log('✅ V5: BMW with MeshBasicMaterial');
    });
}

// V6: Remove cameras/lights from GLTF
function loadBMW_V6_RemoveCameras() {
    console.log('V6: Testing without embedded cameras/lights');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        console.log('Cameras in GLB:', gltf.cameras.length);
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(3, 3, 3);
        scene.add(bmwM8Car);
        bmwM8Car.traverse((child) => {
            if (child.isCamera || child.isLight) child.removeFromParent();
            if (child.isMesh) child.material = new THREE.MeshLambertMaterial({color: 0x0000ff});
        });
        console.log('✅ V6: Cameras/lights removed');
    });
}

// V7: Force all meshes visible
function loadBMW_V7_ForceVisible() {
    console.log('V7: Testing force visible + layer 0');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(4, 4, 4);
        scene.add(bmwM8Car);
        bmwM8Car.traverse((child) => {
            child.visible = true;
            child.layers.set(0);
            if (child.isMesh) {
                child.material = new THREE.MeshLambertMaterial({color: 0xff8800});
                child.material.visible = true;
                child.material.opacity = 1.0;
            }
        });
        console.log('✅ V7: All forced visible');
    });
}

// V8: No helper boxes
function loadBMW_V8_NoHelper() {
    console.log('V8: Testing WITHOUT any helpers');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(2.5, 2.5, 2.5);
        scene.add(bmwM8Car);
        bmwM8Car.traverse((child) => {
            if (child.isMesh) child.material = new THREE.MeshLambertMaterial({color: 0x00ffff});
        });
        // NO BOX HELPER
        console.log('✅ V8: No helpers added');
    });
}

// V9: Extreme scale test
function loadBMW_V9_ExtremeScale() {
    console.log('V9: Testing EXTREME scale (10000x)');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene;
        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(10000, 10000, 10000); // GIGANTIC
        scene.add(bmwM8Car);
        bmwM8Car.traverse((child) => {
            if (child.isMesh) child.material = new THREE.MeshBasicMaterial({color: 0xffffff});
        });
        console.log('✅ V9: EXTREME 10000x scale');
    });
}

// V10: Center geometry to origin
function loadBMW_V10_CenterGeometry() {
    console.log('V10: Testing centered geometry');
    const loader = new GLTFLoader();
    loader.load('2020-bmw-m8-coupe/source/2020_bmw_m8_coupe.glb', (gltf) => {
        bmwM8Car = gltf.scene;

        // Center all geometries
        bmwM8Car.traverse((child) => {
            if (child.isMesh) {
                child.geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                child.geometry.boundingBox.getCenter(center);
                child.geometry.translate(-center.x, -center.y, -center.z);
                child.material = new THREE.MeshLambertMaterial({color: 0xff0088});
            }
        });

        bmwM8Car.position.set(-31.61, 1.5, -191.66);
        bmwM8Car.scale.set(5, 5, 5);
        scene.add(bmwM8Car);
        console.log('✅ V10: Geometry centered');
    });
}

// BMW X6M Competition - Multiple test versions
let bmwX6M = null;

function loadBMW_X6M_Router() {
    const urlParams = new URLSearchParams(window.location.search);
    const x6mVersion = parseInt(urlParams.get('x6m')) || 0;

    console.log('Loading BMW X6M Competition - Version ' + x6mVersion);

    // NOTE: M8 is loaded separately via loadBMWM8Car() - use ?bmw=1 for M8
    // To load BOTH cars: ?bmw=1&x6m=1
    switch(x6mVersion) {
        case 1: loadBMW_X6M_V1_MassiveScale(); break;
        case 2: loadBMW_X6M_V2_BrightMaterial(); break;
        case 3: loadBMW_X6M_V3_HighPosition(); break;
        case 4: loadBMW_X6M_V4_BoundingBox(); break;
        case 5: loadBMW_X6M_V5_LogStructure(); break;
        case 6: loadBMW_X6M_V6_ForceVisible(); break;
        case 7: loadBMW_X6M_V7_RemoveCameras(); break;
        case 8: loadBMW_X6M_V8_DirectPath(); break;
        case 9: loadBMW_X6M_V9_CenterGeometry(); break;
        case 10: loadBMW_X6M_V10_ExtremeScale(); break;
        default:
            console.log('No X6M version specified (x6m=' + x6mVersion + ')');
            console.log('Use ?x6m=1 through ?x6m=10 for X6M Competition');
            console.log('Use ?bmw=1 through ?bmw=10 for M8 Coupe');
            console.log('For BOTH cars: ?bmw=1&x6m=1');
            return;
    }
}

// V1: Same scale as M8 (150x) - positioned near the M8 but at different Z
function loadBMW_X6M_V1_MassiveScale() {
    console.log('V1: Loading X6M with scale 150 (same as M8)');
    console.log('V1: Attempting to load bmw_x6m.glb from:', window.location.origin + '/bmw_x6m.glb');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb',
        // onLoad
        (gltf) => {
            console.log('V1: X6M GLB file loaded successfully!', gltf);
        bmwX6M = gltf.scene;
        // Position at player's current location
        bmwX6M.position.set(-24.26, 1.0, -159.14); // At player's exact position
        bmwX6M.scale.set(1.5, 1.5, 1.5); // Increased size slightly
        scene.add(bmwX6M);

        // Use original materials from the model
        bmwX6M.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // Keep original material but ensure it renders properly
                if (child.material) {
                    child.material.side = THREE.DoubleSide;
                    child.material.needsUpdate = true;
                }
            }
        });

        // Add collision for X6M (scaled dimensions: 1.5x)
        addCollider(-24.26, -159.14, 4.305, 10.935, 3.15, 'BMW X6M Competition', 0);

        // Add hazard lights
        addHazardLightsToCar(bmwX6M, 'BMW X6M Competition');

        // Initialize damage system for this car
        initCarDamageState(bmwX6M, 'BMW X6M Competition');

        console.log('✅ V1: X6M loaded at X: -24.26, Z: -159.14 with scale 1.5x');
    },
    // onProgress
    (xhr) => {
        if (xhr.lengthComputable) {
            const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
            console.log('V1: X6M loading progress: ' + percent + '%');
        }
    },
    // onError
    (error) => {
        console.error('❌ X6M V1 Load Error:', error);
        console.error('Error details:', error.message, error.stack);
    });
}

// V2: Bright Red Material Test (scale 150 to match M8)
function loadBMW_X6M_V2_BrightMaterial() {
    console.log('V2: Testing with bright red MeshBasicMaterial (scale 150)');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;
        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(150, 150, 150); // Same as M8
        scene.add(bmwX6M);
        bmwX6M.traverse((child) => {
            if (child.isMesh) {
                child.material = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    side: THREE.DoubleSide
                });
            }
        });
        console.log('✅ V2: X6M loaded with bright red material');
    }, undefined, (error) => console.error('❌ V2 Error:', error));
}

// V3: High Position Test (Y: 50)
function loadBMW_X6M_V3_HighPosition() {
    console.log('V3: Testing high Y position (Y: 50)');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;
        bmwX6M.position.set(-20, 50, -160); // HIGH IN AIR
        bmwX6M.scale.set(150, 150, 150);
        scene.add(bmwX6M);
        bmwX6M.traverse((child) => {
            if (child.isMesh) {
                child.material = new THREE.MeshLambertMaterial({color: 0x00ff00, side: THREE.DoubleSide});
            }
        });
        console.log('✅ V3: X6M loaded at Y: 50');
    }, undefined, (error) => console.error('❌ V3 Error:', error));
}

// V4: Bounding Box Helper
function loadBMW_X6M_V4_BoundingBox() {
    console.log('V4: Testing with bounding box helper');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;
        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(150, 150, 150);
        scene.add(bmwX6M);

        // Add bright red box helper
        const helper = new THREE.BoxHelper(bmwX6M, 0xff0000);
        scene.add(helper);

        console.log('✅ V4: X6M loaded with red bounding box');
    }, undefined, (error) => console.error('❌ V4 Error:', error));
}

// V5: Log Model Structure
function loadBMW_X6M_V5_LogStructure() {
    console.log('V5: Logging model structure');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;

        console.log('=== X6M MODEL STRUCTURE ===');
        console.log('Scene:', bmwX6M);
        let meshCount = 0;
        bmwX6M.traverse((child) => {
            console.log('Child:', child.type, child.name);
            if (child.isMesh) {
                meshCount++;
                console.log('  Mesh geometry:', child.geometry);
                console.log('  Material:', child.material);
            }
        });
        console.log('Total meshes:', meshCount);

        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(150, 150, 150);
        scene.add(bmwX6M);
        console.log('✅ V5: Check console for structure');
    }, undefined, (error) => console.error('❌ V5 Error:', error));
}

// V6: Force Visibility and DoubleSide
function loadBMW_X6M_V6_ForceVisible() {
    console.log('V6: Forcing visibility on all objects');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;
        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(150, 150, 150);
        scene.add(bmwX6M);

        bmwX6M.traverse((child) => {
            child.visible = true;
            child.frustumCulled = false;
            if (child.isMesh) {
                if (child.material) {
                    child.material.side = THREE.DoubleSide;
                    child.material.needsUpdate = true;
                }
            }
        });
        console.log('✅ V6: All objects forced visible');
    }, undefined, (error) => console.error('❌ V6 Error:', error));
}

// V7: Remove Cameras/Lights
function loadBMW_X6M_V7_RemoveCameras() {
    console.log('V7: Filtering out cameras and lights');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;

        // Remove cameras and lights
        const toRemove = [];
        bmwX6M.traverse((child) => {
            if (child.isCamera || child.isLight) {
                toRemove.push(child);
            }
        });
        toRemove.forEach(obj => obj.parent?.remove(obj));
        console.log('Removed', toRemove.length, 'cameras/lights');

        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(150, 150, 150);
        scene.add(bmwX6M);

        bmwX6M.traverse((child) => {
            if (child.isMesh) {
                child.material = new THREE.MeshLambertMaterial({color: 0xff00ff, side: THREE.DoubleSide});
            }
        });
        console.log('✅ V7: Cameras/lights removed');
    }, undefined, (error) => console.error('❌ V7 Error:', error));
}

// V8: Load from Downloads folder directly
function loadBMW_X6M_V8_DirectPath() {
    console.log('V8: Loading from Downloads folder directly');
    const loader = new GLTFLoader();

    loader.load('/Users/paulbridges/Downloads/bmw_x6m_competition_assetto__www.vecarz.com.glb', (gltf) => {
        bmwX6M = gltf.scene;
        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(150, 150, 150);
        scene.add(bmwX6M);
        bmwX6M.traverse((child) => {
            if (child.isMesh) {
                child.material = new THREE.MeshLambertMaterial({color: 0xffff00, side: THREE.DoubleSide});
            }
        });
        console.log('✅ V8: Loaded from Downloads folder');
    }, undefined, (error) => console.error('❌ V8 Error:', error));
}

// V9: Center Geometry
function loadBMW_X6M_V9_CenterGeometry() {
    console.log('V9: Centering geometry to origin');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;

        // Center all geometries
        bmwX6M.traverse((child) => {
            if (child.isMesh) {
                child.geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                child.geometry.boundingBox.getCenter(center);
                child.geometry.translate(-center.x, -center.y, -center.z);
                child.material = new THREE.MeshLambertMaterial({color: 0x0088ff, side: THREE.DoubleSide});
            }
        });

        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(150, 150, 150);
        scene.add(bmwX6M);
        console.log('✅ V9: Geometry centered');
    }, undefined, (error) => console.error('❌ V9 Error:', error));
}

// V10: Extreme Scale (5000x)
function loadBMW_X6M_V10_ExtremeScale() {
    console.log('V10: Testing EXTREME Scale (5000x)');
    const loader = new GLTFLoader();

    loader.load('bmw_x6m.glb', (gltf) => {
        bmwX6M = gltf.scene;
        bmwX6M.position.set(-20, 0, -160);
        bmwX6M.scale.set(5000, 5000, 5000); // EXTREME
        scene.add(bmwX6M);
        bmwX6M.traverse((child) => {
            if (child.isMesh) {
                child.material = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide});
            }
        });
        console.log('✅ V10: X6M loaded with 5000x scale');
    }, undefined, (error) => console.error('❌ V10 Error:', error));
}

// Volkswagen T-Cross - Testing implementation
let vwTCross = null;

function loadVW_TCross_Router() {
    const urlParams = new URLSearchParams(window.location.search);
    const vwVersion = parseInt(urlParams.get('vw')) || 0;

    console.log('Loading Volkswagen T-Cross - Version ' + vwVersion);

    switch(vwVersion) {
        case 1: loadVW_TCross_V1_InitialTest(); break;
        case 2: loadVW_TCross_V2_Bigger_OnFloor(); break;
        default:
            console.log('No VW T-Cross version specified (vw=' + vwVersion + ')');
            console.log('Use ?vw=1 to load VW T-Cross');
            return;
    }
}

// V1: Initial test - start with scale 1.0, test and adjust
function loadVW_TCross_V1_InitialTest() {
    console.log('V1: Loading VW T-Cross at player position with initial 1.0x scale');
    console.log('V1: Attempting to load from: vw_tcross.glb');

    const loader = new GLTFLoader();

    loader.load('vw_tcross.glb',
        // onLoad
        (gltf) => {
            console.log('V1: VW T-Cross GLB file loaded successfully!', gltf);
            vwTCross = gltf.scene;

            // Position at player's current location: X: -33.63, Z: -174.36
            vwTCross.position.set(-33.63, 1.0, -174.36);

            // Start with 1.0x scale to see actual model size
            vwTCross.scale.set(1.0, 1.0, 1.0);

            scene.add(vwTCross);

            // Use original materials with DoubleSide
            vwTCross.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.side = THREE.DoubleSide;
                        child.material.needsUpdate = true;
                    }
                }
            });

            // VW T-Cross dimensions (compact SUV): ~4.1m length, ~1.8m width, ~1.6m height
            // Add collision box - will adjust after seeing actual scale
            addCollider(-33.63, -174.36, 1.8, 4.1, 1.6, 'Volkswagen T-Cross', 0);

            console.log('✅ V1: VW T-Cross loaded at X: -33.63, Z: -174.36 with scale 1.0x');
            console.log('Check visibility. If too small, try ?vw=2 for larger scale. If too big, try ?vw=3 for smaller scale.');
        },
        // onProgress
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                console.log('V1: VW T-Cross loading progress: ' + percent + '%');
            }
        },
        // onError
        (error) => {
            console.error('❌ VW T-Cross V1 Load Error:', error);
            console.error('Error details:', error.message, error.stack);
            console.error('File path attempted: vw_tcross.glb');
        }
    );
}

// V2: Bigger scale (1.5x) and on the floor (Y=0.1)
function loadVW_TCross_V2_Bigger_OnFloor() {
    console.log('V2: Loading VW T-Cross - 1.5x scale, on floor');
    console.log('V2: Attempting to load from: vw_tcross.glb');

    const loader = new GLTFLoader();

    loader.load('vw_tcross.glb',
        // onLoad
        (gltf) => {
            console.log('V2: VW T-Cross GLB file loaded successfully!', gltf);
            vwTCross = gltf.scene;

            // Position at player's location: X: -33.63, Z: -174.36, Y: 0.1 (on floor)
            vwTCross.position.set(-33.63, 0.1, -174.36);

            // Scale 1.5x (like X6M)
            vwTCross.scale.set(1.5, 1.5, 1.5);

            scene.add(vwTCross);

            // Use original materials with DoubleSide
            vwTCross.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.side = THREE.DoubleSide;
                        child.material.needsUpdate = true;
                    }
                }
            });

            // VW T-Cross dimensions scaled 1.5x: ~6.15m length, ~2.7m width, ~2.4m height
            addCollider(-33.63, -174.36, 2.7, 6.15, 2.4, 'Volkswagen T-Cross', 0);

            // Add hazard lights
            addHazardLightsToCar(vwTCross, 'Volkswagen T-Cross');

            // Initialize damage system for this car
            initCarDamageState(vwTCross, 'Volkswagen T-Cross');

            console.log('✅ V2: VW T-Cross loaded at X: -33.63, Y: 0.1, Z: -174.36 with scale 1.5x');
            console.log('V2: Car should be on the floor and slightly bigger. Try ?vw=3 if still too small, ?vw=1 if too big.');
        },
        // onProgress
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                console.log('V2: VW T-Cross loading progress: ' + percent + '%');
            }
        },
        // onError
        (error) => {
            console.error('❌ VW T-Cross V2 Load Error:', error);
            console.error('Error details:', error.message, error.stack);
            console.error('File path attempted: vw_tcross.glb');
        }
    );
}

function createTunnelColliders() {
    // Add collision boxes for tunnel walls - TIGHT to visual structure only
    if (!urbanEnvironment) {
        console.log('Cannot create tunnel colliders - environment not loaded');
        return;
    }

    // Get bounding box for tunnel length
    const box = new THREE.Box3().setFromObject(urbanEnvironment);
    const tunnelMinZ = box.min.z;
    const tunnelMaxZ = box.max.z;
    const tunnelLength = tunnelMaxZ - tunnelMinZ;
    const tunnelCenterZ = (tunnelMinZ + tunnelMaxZ) / 2;

    console.log('=== TUNNEL DIMENSIONS ===');
    console.log('Z range (length):', tunnelMinZ.toFixed(2), 'to', tunnelMaxZ.toFixed(2));

    const wallThickness = 2;      // Thin walls
    const wallHeight = 10;        // Tall walls

    // COLLISION WALLS based on step tracker data
    // User walked X: -38.11 to +10.93
    // Scale 800 gives visual walls at approximately X=+/-30 (before shift)
    // With shift of -13.5:
    // Left wall: -30 + (-13.5) = -43.5 (contains user at X=-38)
    // Right wall: +30 + (-13.5) = +16.5 (contains user at X=+11)
    const leftWallX = -43.5;    // Left wall position (shifted)
    const rightWallX = 16.5;    // Right wall position (shifted)

    // OLD COLLISION WALLS - DISABLED (using new CollisionSystem versions instead)
    // Left wall - at visible tunnel left edge
    // addCollider(
    //     leftWallX,             // X position (visible structure left)
    //     tunnelCenterZ,         // Z position (center of tunnel)
    //     wallThickness,         // Width of wall
    //     tunnelLength,          // Depth (extends full tunnel length)
    //     wallHeight,            // Height
    //     'Tunnel Left Wall (Visible Structure)'
    // );

    // Right wall - at visible tunnel right edge
    // addCollider(
    //     rightWallX,            // X position (visible structure right)
    //     tunnelCenterZ,         // Z position (center of tunnel)
    //     wallThickness,         // Width of wall
    //     tunnelLength,          // Depth (extends full tunnel length)
    //     wallHeight,            // Height
    //     'Tunnel Right Wall (Visible Structure)'
    // );

    // ENTRANCE WALL - Blocks backward movement out of tunnel
    // User's starting position is at Z: -231.69, add wall slightly behind to prevent exiting
    const entranceWallZ = -232;  // Slightly behind starting position
    const tunnelWidth = rightWallX - leftWallX;  // Width from left to right wall
    const tunnelCenterX = (leftWallX + rightWallX) / 2;  // Center X position

    addCollider(
        tunnelCenterX,         // X position (center of tunnel)
        entranceWallZ,         // Z position (at entrance, behind starting point)
        tunnelWidth,           // Width (spans full tunnel width)
        wallThickness,         // Depth (thin wall perpendicular to Z)
        wallHeight,            // Height
        'Tunnel Entrance Wall (Blocks Backward Exit)'
    );

    console.log('=== ENTRANCE WALL ADDED at Z=' + entranceWallZ + ' ===');
    console.log('Prevents character from exiting tunnel backwards');
    console.log('=== OLD COLLISION WALLS DISABLED - Using CollisionSystem versions ===');
    console.log('Left wall was at X=' + leftWallX);
    console.log('Right wall was at X=' + rightWallX);
    console.log('Playable width: 60 units (contains step tracker X range -38 to +11)');

    // Hide collision boxes by default - ALWAYS hidden
    toggleCollisionDebug(false);

    // Also hide them after a delay to catch any late additions
    setTimeout(() => toggleCollisionDebug(false), 1000);
}

function addWallMarkers(leftX, rightX, tunnelMinZ, tunnelMaxZ) {
    console.log('Adding visual wall markers at EXACT tunnel edges...');

    // Add markers every 30 units along the walls
    const markerInterval = 30;
    const numMarkers = Math.floor((tunnelMaxZ - tunnelMinZ) / markerInterval);

    for (let i = 0; i <= numMarkers; i++) {
        const zPos = tunnelMinZ + (i * markerInterval);

        // Left wall marker (bright cyan sphere) - at EXACT left edge
        const leftMarkerGeometry = new THREE.SphereGeometry(1.5, 8, 8);
        const leftMarkerMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 1
        });
        const leftMarker = new THREE.Mesh(leftMarkerGeometry, leftMarkerMaterial);
        leftMarker.position.set(leftX, 2, zPos);
        scene.add(leftMarker);

        // Right wall marker (bright magenta sphere) - at EXACT right edge
        const rightMarkerGeometry = new THREE.SphereGeometry(1.5, 8, 8);
        const rightMarkerMaterial = new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            emissive: 0xff00ff,
            emissiveIntensity: 1
        });
        const rightMarker = new THREE.Mesh(rightMarkerGeometry, rightMarkerMaterial);
        rightMarker.position.set(rightX, 2, zPos);
        scene.add(rightMarker);
    }

    console.log(`Added ${numMarkers * 2} wall markers at EXACT positions:`);
    console.log(`  CYAN (left) at X=${leftX.toFixed(2)}`);
    console.log(`  MAGENTA (right) at X=${rightX.toFixed(2)}`);
}

function addTunnelMarkers(tunnelStart, tunnelEnd) {
    // Add distance markers every 20 units with different colors
    console.log('Adding tunnel distance markers...');

    const markerInterval = 20;
    const totalDistance = tunnelEnd - tunnelStart;
    const numMarkers = Math.floor(totalDistance / markerInterval);

    const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];

    for (let i = 0; i <= numMarkers; i++) {
        const zPos = tunnelStart + (i * markerInterval);
        const distance = Math.abs(zPos - tunnelStart);
        const color = colors[i % colors.length];

        console.log('Creating marker ' + i + ' at Z=' + zPos.toFixed(2) + ' showing "' + distance + 'm"');

        // Create marker text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 256;

        // Draw background
        context.fillStyle = '#000000';
        context.fillRect(0, 0, 512, 256);

        // Draw text in alternating colors
        context.fillStyle = color;
        context.font = 'Bold 100px Arial';
        context.textAlign = 'center';
        context.fillText(distance + 'm', 256, 160);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);

        sprite.position.set(-5, 5, zPos); // Left wall, higher up
        sprite.scale.set(3, 1.5, 1); // Reasonable size
        scene.add(sprite);

        // Add duplicate on right side
        const sprite2 = sprite.clone();
        sprite2.position.set(5, 5, zPos);
        scene.add(sprite2);
    }

    // Add EXIT marker at the end
    const exitCanvas = document.createElement('canvas');
    const exitContext = exitCanvas.getContext('2d');
    exitCanvas.width = 512;
    exitCanvas.height = 256;

    exitContext.fillStyle = '#000000';
    exitContext.fillRect(0, 0, 512, 256);
    exitContext.fillStyle = '#00ff00';
    exitContext.font = 'Bold 120px Arial';
    exitContext.textAlign = 'center';
    exitContext.fillText('START', 256, 180);

    const exitTexture = new THREE.CanvasTexture(exitCanvas);
    const exitSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: exitTexture }));
    exitSprite.position.set(0, 5, tunnelEnd - 10);
    exitSprite.scale.set(6, 3, 1); // Reasonable size
    scene.add(exitSprite);

    // Add bright light at exit
    const exitLight = new THREE.PointLight(0x00ff00, 5, 80);
    exitLight.position.set(0, 3, tunnelEnd - 5);
    scene.add(exitLight);

    console.log('Added ' + (numMarkers + 1) + ' distance markers and exit sign');
}

function addCollider(x, z, width, depth, height, label = '', rotationY = 0) {
    const collider = {
        x: x,
        z: z,
        width: width,
        depth: depth,
        height: height,
        label: label,
        rotationY: rotationY // Rotation in degrees
    };

    environmentColliders.push(collider);

    // Create debug visualization (wireframe box) - BRIGHT AND VISIBLE
    const debugGeometry = new THREE.BoxGeometry(width, height, depth);
    const debugMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true,
        transparent: false,  // Make it fully opaque
        opacity: 1.0,
        depthTest: false,    // Render on top of everything
        depthWrite: false
    });
    const debugBox = new THREE.Mesh(debugGeometry, debugMaterial);
    debugBox.position.set(x, height / 2, z);
    debugBox.rotation.y = THREE.MathUtils.degToRad(rotationY);
    debugBox.renderOrder = 999; // Render last (on top)
    debugBox.visible = false; // Hidden by default
    scene.add(debugBox);
    debugCollisionBoxes.push(debugBox);

    // Also add a solid colored box to make it even more visible
    const solidGeometry = new THREE.BoxGeometry(width * 0.9, height * 0.9, depth * 0.9);
    const solidMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide
    });
    const solidBox = new THREE.Mesh(solidGeometry, solidMaterial);
    solidBox.position.set(x, height / 2, z);
    solidBox.rotation.y = THREE.MathUtils.degToRad(rotationY);
    solidBox.visible = false; // Hidden by default
    scene.add(solidBox);
    debugCollisionBoxes.push(solidBox);

    console.log(`✅ Collider added: ${label || 'Unnamed'} at X=${x}, Z=${z} (Width=${width}, Depth=${depth}, Height=${height}, Rotation=${rotationY}°)`);
}

function toggleCollisionDebug(show) {
    debugCollisionBoxes.forEach(box => {
        box.visible = show;
    });
}

function checkEnvironmentCollision(newX, newZ, radius = 0.5) {
    for (const collider of environmentColliders) {
        const halfWidth = collider.width / 2;
        const halfDepth = collider.depth / 2;

        // Handle rotated boxes (OBB collision)
        if (collider.rotationY && collider.rotationY !== 0) {
            // Transform player position to box's local space
            const angleRad = -THREE.MathUtils.degToRad(collider.rotationY);
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);

            // Translate to box origin
            const dx = newX - collider.x;
            const dz = newZ - collider.z;

            // Rotate to box's local space
            const localX = dx * cos - dz * sin;
            const localZ = dx * sin + dz * cos;

            // Now do AABB collision in local space
            const closestX = Math.max(-halfWidth, Math.min(localX, halfWidth));
            const closestZ = Math.max(-halfDepth, Math.min(localZ, halfDepth));

            const distanceX = localX - closestX;
            const distanceZ = localZ - closestZ;
            const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;

            if (distanceSquared < (radius * radius)) {
                return true; // Collision detected!
            }
        } else {
            // Standard AABB collision (no rotation)
            const closestX = Math.max(collider.x - halfWidth, Math.min(newX, collider.x + halfWidth));
            const closestZ = Math.max(collider.z - halfDepth, Math.min(newZ, collider.z + halfDepth));

            const distanceX = newX - closestX;
            const distanceZ = newZ - closestZ;
            const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;

            if (distanceSquared < (radius * radius)) {
                return true; // Collision detected!
            }
        }
    }
    return false; // No collision
}

// RALPH: Expose for debugging
window.checkEnvironmentCollision = checkEnvironmentCollision;

// ============================================================================
// COLLISION SYSTEM - 10 Different Implementations
// ============================================================================

const CollisionSystem = {
    currentVersion: 0, // 0 = original, 1-10 = new versions
    tunnelMesh: null,
    implementations: {},
    debugVisualization: [],

    init(tunnelScene) {
        this.tunnelMesh = tunnelScene;
        console.log('🎯 Initializing CollisionSystem with', Object.keys(this.implementations).length, 'versions');

        // Check URL parameter for version (e.g., ?v=2 or ?version=5)
        const urlParams = new URLSearchParams(window.location.search);
        let urlVersion = urlParams.get('v') || urlParams.get('version');

        // DEFAULT: Use V2 if no parameter specified
        if (urlVersion === null) {
            urlVersion = '2';
            console.log('📍 No URL parameter - defaulting to V2 (Multi-Directional Raycasting)');
        }

        if (urlVersion !== null) {
            const versionNum = parseInt(urlVersion);
            if (versionNum >= 0 && versionNum <= 2) {
                this.currentVersion = versionNum;
                console.log('📍 Using collision version: V' + versionNum);
            } else {
                console.warn('⚠️ Invalid collision version:', versionNum, '(only V0, V1, V2 are available). Defaulting to V2.');
                this.currentVersion = 2;
            }
        }

        // Initialize current version
        if (this.implementations[this.currentVersion] && this.implementations[this.currentVersion].init) {
            this.implementations[this.currentVersion].init(tunnelScene);
        }

        // Show which version is active
        if (this.currentVersion !== 0) {
            this.showVersionNotification(this.currentVersion);
        }
    },

    setVersion(version) {
        if (version < 0 || version > 2) {
            console.error('Invalid version:', version, '(only V0, V1, V2 are available)');
            return;
        }

        // Cleanup old version
        if (this.implementations[this.currentVersion] && this.implementations[this.currentVersion].cleanup) {
            this.implementations[this.currentVersion].cleanup();
        }

        this.currentVersion = version;
        console.log('🔄 Switched to collision V' + version + ':', this.getVersionName(version));

        // Update URL parameter
        const url = new URL(window.location);
        if (version === 0) {
            url.searchParams.delete('v');
        } else {
            url.searchParams.set('v', version);
        }
        window.history.pushState({}, '', url);

        // Initialize new version
        if (this.tunnelMesh && this.implementations[version] && this.implementations[version].init) {
            this.implementations[version].init(this.tunnelMesh);
        }

        // Show notification
        this.showVersionNotification(version);
    },

    checkCollision(newX, newZ, radius = 0.5) {
        if (this.currentVersion === 0) {
            // Use original collision function
            return checkEnvironmentCollision(newX, newZ, radius);
        }

        const impl = this.implementations[this.currentVersion];
        if (impl && impl.checkCollision) {
            return impl.checkCollision(new THREE.Vector3(newX, 1.0, newZ), radius);
        }

        return false;
    },

    getVersionName(version) {
        const names = {
            0: 'Original (Simple Walls)',
            1: 'BVH with three-mesh-bvh',
            2: 'Multi-Directional Raycasting'
        };
        return names[version] || 'Unknown';
    },

    showVersionNotification(version) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 20px 40px;
            border: 2px solid #00ff00;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            z-index: 10000;
            text-align: center;
        `;
        notification.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 10px;">🎯 COLLISION SYSTEM</div>
            <div>Version ${version}</div>
            <div style="font-size: 14px; margin-top: 10px; color: #ffff00;">${this.getVersionName(version)}</div>
        `;
        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.transition = 'opacity 0.5s';
            notification.style.opacity = '0';
            setTimeout(() => document.body.removeChild(notification), 500);
        }, 2000);
    }
};

// Expose globally for console access
window.CollisionSystem = CollisionSystem;
window.setCollisionVersion = (v) => CollisionSystem.setVersion(v);


// ============================================================================
// V2: Multi-Directional Raycasting (360° Detection)
// ============================================================================

CollisionSystem.implementations[2] = {
    raycaster: null,
    rayCount: 12,
    rayLength: 2.0,
    rayDirections: [],
    tunnelMeshes: [],

    init(tunnelScene) {
        console.log('V2: Setting up multi-directional raycasting...');
        this.raycaster = new THREE.Raycaster();
        this.rayDirections = [];
        this.tunnelMeshes = [];

        // Pre-compute ray directions in 360°
        for (let i = 0; i < this.rayCount; i++) {
            const angle = (i / this.rayCount) * Math.PI * 2;
            this.rayDirections.push(new THREE.Vector3(
                Math.cos(angle), 0, Math.sin(angle)
            ));
        }

        tunnelScene.traverse((child) => {
            if (child.isMesh) {
                this.tunnelMeshes.push(child);
            }
        });

        console.log('✅ V2:', this.rayCount, 'rays ready, tracking', this.tunnelMeshes.length, 'meshes');
    },

    checkCollision(position, radius) {
        const origin = position.clone();
        origin.y = 1.0; // Cast at player height

        // First check raycasting against tunnel mesh
        for (const dir of this.rayDirections) {
            this.raycaster.set(origin, dir);
            this.raycaster.far = this.rayLength;

            const hits = this.raycaster.intersectObjects(this.tunnelMeshes, false);

            if (hits.length > 0 && hits[0].distance < radius + 0.5) {
                return true; // Wall detected
            }
        }

        // Also check environmentColliders (like entrance wall)
        if (checkEnvironmentCollision(position.x, position.z, radius)) {
            return true; // Entrance wall or other collider detected
        }

        return false;
    },

    cleanup() {
        this.tunnelMeshes = [];
    }
};


// ============================================================================
// V1: BVH with three-mesh-bvh (Requires Library)
// ============================================================================

CollisionSystem.implementations[1] = {
    bvhMeshes: [],
    playerCapsule: null,

    init(tunnelScene) {
        console.log('V1: Initializing BVH collision...');

        // Check if library is loaded
        if (typeof window.MeshBVHLib === 'undefined') {
            console.warn('⚠️ V1: three-mesh-bvh library not loaded. Add to importmap in index.html');
            console.warn('This version will fall back to simple raycasting.');
            // Fallback to simple collision
            this.useFallback = true;
            return;
        }

        this.bvhMeshes = [];

        tunnelScene.traverse((child) => {
            if (child.isMesh && child.geometry) {
                // Compute BVH for mesh
                child.geometry.computeBoundsTree();
                this.bvhMeshes.push(child);
            }
        });

        console.log('✅ V1: BVH computed for', this.bvhMeshes.length, 'meshes');
    },

    checkCollision(position, radius) {
        if (this.useFallback) {
            // Fallback to environment colliders
            return checkEnvironmentCollision(position.x, position.z, radius);
        }

        // BVH-based collision would go here
        // For now, use environment colliders check
        if (checkEnvironmentCollision(position.x, position.z, radius)) {
            return true; // Entrance wall or other collider detected
        }

        return false;
    },

    cleanup() {
        this.bvhMeshes.forEach(mesh => {
            if (mesh.geometry.disposeBoundsTree) {
                mesh.geometry.disposeBoundsTree();
            }
        });
        this.bvhMeshes = [];
    }
};


// ============================================================================
// DEBUG POSITION DASHBOARD
// ============================================================================

let debugDashboard = null;

// ============================================================================
// STEP TRACKER - Records position trail for collision wall placement
// ============================================================================

let stepTracker = {
    isRecording: false,
    steps: [],
    lastRecordedPos: null,
    recordInterval: 0.1, // Record every 0.1 seconds
    timeSinceLastRecord: 0,
    startTime: null,
    minDistance: 0.5, // Only record if moved at least 0.5 units

    start() {
        this.isRecording = true;
        this.steps = [];
        this.lastRecordedPos = null;
        this.startTime = Date.now();
        this.timeSinceLastRecord = 0;
        console.log('📍 Step Tracker: Recording STARTED');
        updateStepTrackerUI();
    },

    stop() {
        this.isRecording = false;
        console.log('📍 Step Tracker: Recording STOPPED');
        console.log('Total steps recorded:', this.steps.length);
        this.exportData();
        updateStepTrackerUI();
    },

    reset() {
        this.steps = [];
        this.lastRecordedPos = null;
        this.timeSinceLastRecord = 0;
        console.log('📍 Step Tracker: Data RESET');
        updateStepTrackerUI();
    },

    record(delta) {
        if (!this.isRecording || !shooterModel) return;

        this.timeSinceLastRecord += delta;

        // Record at intervals
        if (this.timeSinceLastRecord >= this.recordInterval) {
            const currentPos = {
                x: shooterModel.position.x,
                y: shooterModel.position.y,
                z: shooterModel.position.z
            };

            // Only record if moved significantly or first position
            if (!this.lastRecordedPos || this.hasMovedSignificantly(currentPos)) {
                const timeElapsed = ((Date.now() - this.startTime) / 1000).toFixed(2);

                this.steps.push({
                    step: this.steps.length + 1,
                    time: timeElapsed,
                    x: currentPos.x.toFixed(2),
                    y: currentPos.y.toFixed(2),
                    z: currentPos.z.toFixed(2),
                    distance: this.lastRecordedPos ? this.calculateDistance(currentPos) : 0
                });

                this.lastRecordedPos = currentPos;
                updateStepTrackerUI();
            }

            this.timeSinceLastRecord = 0;
        }
    },

    hasMovedSignificantly(currentPos) {
        if (!this.lastRecordedPos) return true;

        const dx = currentPos.x - this.lastRecordedPos.x;
        const dy = currentPos.y - this.lastRecordedPos.y;
        const dz = currentPos.z - this.lastRecordedPos.z;
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

        return distance >= this.minDistance;
    },

    calculateDistance(currentPos) {
        const dx = currentPos.x - this.lastRecordedPos.x;
        const dy = currentPos.y - this.lastRecordedPos.y;
        const dz = currentPos.z - this.lastRecordedPos.z;
        return Math.sqrt(dx*dx + dy*dy + dz*dz).toFixed(2);
    },

    exportData() {
        console.log('=== STEP TRACKER DATA EXPORT ===');
        console.log('Total Steps:', this.steps.length);
        console.log('Duration:', ((Date.now() - this.startTime) / 1000).toFixed(2), 'seconds');
        console.log('\nPosition Data:');
        this.steps.forEach(step => {
            console.log(`Step ${step.step}: X=${step.x}, Y=${step.y}, Z=${step.z} (${step.time}s, moved ${step.distance}m)`);
        });

        // Calculate bounds
        if (this.steps.length > 0) {
            const xValues = this.steps.map(s => parseFloat(s.x));
            const zValues = this.steps.map(s => parseFloat(s.z));

            console.log('\n=== COLLISION BOUNDS ===');
            console.log('X Range:', Math.min(...xValues).toFixed(2), 'to', Math.max(...xValues).toFixed(2));
            console.log('Z Range:', Math.min(...zValues).toFixed(2), 'to', Math.max(...zValues).toFixed(2));
        }
    },

    getTotalDistance() {
        return this.steps.reduce((sum, step) => sum + parseFloat(step.distance), 0).toFixed(2);
    },

    getBounds() {
        if (this.steps.length === 0) return null;

        const xValues = this.steps.map(s => parseFloat(s.x));
        const zValues = this.steps.map(s => parseFloat(s.z));

        return {
            minX: Math.min(...xValues).toFixed(2),
            maxX: Math.max(...xValues).toFixed(2),
            minZ: Math.min(...zValues).toFixed(2),
            maxZ: Math.max(...zValues).toFixed(2)
        };
    }
};

let stepTrackerDashboard = null;

function createDebugDashboard() {
    if (debugDashboard) return; // Already created

    const dashboard = document.createElement('div');
    dashboard.id = 'debug-dashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        color: #00ff00;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        padding: 15px;
        border: 2px solid #00ff00;
        border-radius: 8px;
        z-index: 1000;
        min-width: 300px;
        pointer-events: auto;
    `;

    dashboard.innerHTML = `
        <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px; color: #ffff00;">
            🎯 DEBUG POSITION TRACKER
        </div>
        <div style="margin-bottom: 8px;">
            <strong>Position:</strong><br>
            X: <span id="debug-pos-x">0.00</span><br>
            Y: <span id="debug-pos-y">0.00</span><br>
            Z: <span id="debug-pos-z">0.00</span>
        </div>
        <div style="margin-bottom: 8px;">
            <strong>Rotation:</strong> <span id="debug-rot-y">0.00</span>°
        </div>
        <div style="margin-bottom: 8px;">
            <strong>Velocity:</strong><br>
            X: <span id="debug-vel-x">0.00</span><br>
            Z: <span id="debug-vel-z">0.00</span>
        </div>
        <hr style="border-color: #00ff00; margin: 10px 0;">
        <div style="font-weight: bold; margin-bottom: 5px;">TELEPORT TO:</div>
        <div style="margin-bottom: 5px;">
            X: <input type="number" id="teleport-x" step="0.1" value="0" style="width: 70px; background: #222; color: #0f0; border: 1px solid #0f0; padding: 2px;">
            Y: <input type="number" id="teleport-y" step="0.1" value="1" style="width: 70px; background: #222; color: #0f0; border: 1px solid #0f0; padding: 2px;">
            Z: <input type="number" id="teleport-z" step="0.1" value="0" style="width: 70px; background: #222; color: #0f0; border: 1px solid #0f0; padding: 2px;">
        </div>
        <button id="teleport-btn" style="
            background: #00ff00;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 5px;
        ">TELEPORT NOW</button>
        <div style="margin-top: 10px; font-size: 11px; color: #888;">
            Quick presets:<br>
            <button class="preset-btn" data-x="${LEVEL_CONFIG.ANIMATION_TESTING_START.x}" data-y="${LEVEL_CONFIG.ANIMATION_TESTING_START.y}" data-z="${LEVEL_CONFIG.ANIMATION_TESTING_START.z}">STARTING POINT</button>
            <button class="preset-btn" data-x="0" data-y="1" data-z="0">Tunnel center</button>
        </div>
    `;

    // Add preset button styles
    const style = document.createElement('style');
    style.textContent = `
        .preset-btn {
            background: #333;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .preset-btn:hover {
            background: #0f0;
            color: #000;
        }
    `;
    document.head.appendChild(style);

    document.body.appendChild(dashboard);
    debugDashboard = dashboard;

    // Add teleport button functionality
    document.getElementById('teleport-btn').addEventListener('click', () => {
        if (!shooterModel) return;

        const x = parseFloat(document.getElementById('teleport-x').value);
        const y = parseFloat(document.getElementById('teleport-y').value);
        const z = parseFloat(document.getElementById('teleport-z').value);

        shooterModel.position.set(x, y, z);
        console.log(`TELEPORTED to X:${x.toFixed(2)}, Y:${y.toFixed(2)}, Z:${z.toFixed(2)}`);
    });

    // Add preset button functionality
    dashboard.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.getElementById('teleport-x').value = btn.dataset.x;
            document.getElementById('teleport-y').value = btn.dataset.y;
            document.getElementById('teleport-z').value = btn.dataset.z;
        });
    });

    console.log('Debug dashboard created');
}

function updateDebugDashboard() {
    if (!debugDashboard || !shooterModel) return;

    // Update position
    document.getElementById('debug-pos-x').textContent = shooterModel.position.x.toFixed(2);
    document.getElementById('debug-pos-y').textContent = shooterModel.position.y.toFixed(2);
    document.getElementById('debug-pos-z').textContent = shooterModel.position.z.toFixed(2);

    // Update rotation (convert from radians to degrees)
    const rotDeg = (shooterModel.rotation.y * 180 / Math.PI).toFixed(2);
    document.getElementById('debug-rot-y').textContent = rotDeg;

    // Update velocity
    if (MazeController.velocity) {
        document.getElementById('debug-vel-x').textContent = MazeController.velocity.x.toFixed(2);
        document.getElementById('debug-vel-z').textContent = MazeController.velocity.z.toFixed(2);
    }
}

function removeDebugDashboard() {
    if (debugDashboard) {
        debugDashboard.remove();
        debugDashboard = null;
    }
}

// ============================================================================
// STEP TRACKER DASHBOARD UI
// ============================================================================

function createStepTrackerDashboard() {
    if (stepTrackerDashboard) return; // Already created

    const dashboard = document.createElement('div');
    dashboard.id = 'step-tracker-dashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 80px;
        left: 20px;
        background: rgba(0, 0, 0, 0.9);
        color: #00ff00;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        padding: 15px;
        border: 2px solid #ff6600;
        border-radius: 8px;
        z-index: 1000;
        width: 350px;
        max-height: 80vh;
        overflow-y: auto;
        pointer-events: auto;
    `;

    dashboard.innerHTML = `
        <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px; color: #ff6600;">
            📍 STEP TRACKER
        </div>

        <div style="margin-bottom: 10px; padding: 10px; background: rgba(255,102,0,0.1); border: 1px solid #ff6600; border-radius: 4px;">
            <div style="font-weight: bold; margin-bottom: 5px;">STATUS: <span id="tracker-status" style="color: #ffff00;">READY</span></div>
            <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                <button id="tracker-start-btn" style="
                    flex: 1;
                    background: #00ff00;
                    color: #000;
                    border: none;
                    padding: 8px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                ">START</button>
                <button id="tracker-stop-btn" style="
                    flex: 1;
                    background: #ff0000;
                    color: #fff;
                    border: none;
                    padding: 8px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                " disabled>STOP</button>
            </div>
            <button id="tracker-reset-btn" style="
                width: 100%;
                background: #666;
                color: #fff;
                border: none;
                padding: 6px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
            ">RESET DATA</button>
        </div>

        <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,255,0,0.05); border: 1px solid #0f0; border-radius: 4px;">
            <div style="font-weight: bold; margin-bottom: 5px; color: #ffff00;">SUMMARY:</div>
            <div>Steps: <span id="tracker-step-count" style="color: #fff;">0</span></div>
            <div>Distance: <span id="tracker-distance" style="color: #fff;">0.00</span>m</div>
            <div>Time: <span id="tracker-time" style="color: #fff;">0.00</span>s</div>
        </div>

        <div id="tracker-bounds" style="display: none; margin-bottom: 10px; padding: 8px; background: rgba(255,255,0,0.1); border: 1px solid #ff0; border-radius: 4px;">
            <div style="font-weight: bold; margin-bottom: 5px; color: #ffff00;">COLLISION BOUNDS:</div>
            <div style="font-size: 11px;">
                X: <span id="tracker-min-x">0</span> to <span id="tracker-max-x">0</span><br>
                Z: <span id="tracker-min-z">0</span> to <span id="tracker-max-z">0</span>
            </div>
        </div>

        <div style="margin-bottom: 5px; font-weight: bold; border-bottom: 1px solid #ff6600; padding-bottom: 5px;">
            RECORDED STEPS:
        </div>

        <div id="tracker-steps-list" style="
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.4;
        ">
            <div style="color: #888; text-align: center; padding: 20px;">
                No steps recorded yet.<br>
                Click START to begin tracking.
            </div>
        </div>

        <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 10px; color: #888;">
            💡 TIP: Walk the path, click STOP, then screenshot this panel to send collision data.
        </div>
    `;

    document.body.appendChild(dashboard);
    stepTrackerDashboard = dashboard;

    // Add button event listeners
    document.getElementById('tracker-start-btn').addEventListener('click', () => {
        stepTracker.start();
        document.getElementById('tracker-start-btn').disabled = true;
        document.getElementById('tracker-stop-btn').disabled = false;
    });

    document.getElementById('tracker-stop-btn').addEventListener('click', () => {
        stepTracker.stop();
        document.getElementById('tracker-start-btn').disabled = false;
        document.getElementById('tracker-stop-btn').disabled = true;
    });

    document.getElementById('tracker-reset-btn').addEventListener('click', () => {
        if (confirm('Reset all recorded steps?')) {
            stepTracker.reset();
            document.getElementById('tracker-start-btn').disabled = false;
            document.getElementById('tracker-stop-btn').disabled = true;
        }
    });

    console.log('Step Tracker Dashboard created');
}

function updateStepTrackerUI() {
    if (!stepTrackerDashboard) return;

    // Update status
    const statusEl = document.getElementById('tracker-status');
    if (stepTracker.isRecording) {
        statusEl.textContent = '🔴 RECORDING';
        statusEl.style.color = '#ff0000';
    } else if (stepTracker.steps.length > 0) {
        statusEl.textContent = '✅ COMPLETED';
        statusEl.style.color = '#00ff00';
    } else {
        statusEl.textContent = 'READY';
        statusEl.style.color = '#ffff00';
    }

    // Update summary
    document.getElementById('tracker-step-count').textContent = stepTracker.steps.length;
    document.getElementById('tracker-distance').textContent = stepTracker.getTotalDistance();

    if (stepTracker.startTime) {
        const elapsed = ((Date.now() - stepTracker.startTime) / 1000).toFixed(2);
        document.getElementById('tracker-time').textContent = elapsed;
    }

    // Update bounds (if we have data)
    const bounds = stepTracker.getBounds();
    if (bounds) {
        document.getElementById('tracker-bounds').style.display = 'block';
        document.getElementById('tracker-min-x').textContent = bounds.minX;
        document.getElementById('tracker-max-x').textContent = bounds.maxX;
        document.getElementById('tracker-min-z').textContent = bounds.minZ;
        document.getElementById('tracker-max-z').textContent = bounds.maxZ;
    } else {
        document.getElementById('tracker-bounds').style.display = 'none';
    }

    // Update steps list
    const listEl = document.getElementById('tracker-steps-list');
    if (stepTracker.steps.length === 0) {
        listEl.innerHTML = `
            <div style="color: #888; text-align: center; padding: 20px;">
                No steps recorded yet.<br>
                Click START to begin tracking.
            </div>
        `;
    } else {
        let html = '<table style="width: 100%; border-collapse: collapse;">';
        html += '<tr style="background: rgba(255,102,0,0.2); font-weight: bold;"><td>#</td><td>X</td><td>Y</td><td>Z</td><td>Dist</td></tr>';

        // Show last 20 steps (most recent first)
        const recentSteps = stepTracker.steps.slice(-20).reverse();
        recentSteps.forEach(step => {
            html += `
                <tr style="border-bottom: 1px solid rgba(255,102,0,0.2);">
                    <td>${step.step}</td>
                    <td>${step.x}</td>
                    <td>${step.y}</td>
                    <td>${step.z}</td>
                    <td style="color: #888;">${step.distance}</td>
                </tr>
            `;
        });

        if (stepTracker.steps.length > 20) {
            html += `<tr><td colspan="5" style="color: #888; text-align: center; padding: 5px;">... showing last 20 of ${stepTracker.steps.length} steps</td></tr>`;
        }

        html += '</table>';
        listEl.innerHTML = html;
    }
}

function removeStepTrackerDashboard() {
    if (stepTrackerDashboard) {
        stepTrackerDashboard.remove();
        stepTrackerDashboard = null;
    }
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

function checkCollisions() {
    if (PlayerController.isInvincible || !playerModel) return;

    // Check obstacle collisions
    obstacles.forEach(obstacle => {
        if (obstacle.active) {
            const distance = Math.abs(obstacle.mesh.position.z - playerModel.position.z);
            const sameColumn = obstacle.lane === PlayerController.targetLane;

            if (distance < 1.5 && sameColumn) {
                handlePlayerHit();
                obstacle.deactivate();
            }
        }
    });

    // Check enemy collision
    if (enemyModel) {
        const distance = playerModel.position.distanceTo(enemyModel.position);
        if (distance < 2) {
            if (GameState.currentMode === 'CHASE') {
                GameState.score += 1000;
                console.log('Caught enemy! +1000');
                enemyModel.position.z = -20;
            } else {
                handlePlayerHit();
            }
        }
    }
}

function handlePlayerHit() {
    GameState.lives--;
    PlayerController.isInvincible = true;
    PlayerController.invincibilityTimer = 2;

    console.log(`Hit! Lives: ${GameState.lives}`);

    if (GameState.lives <= 0) {
        gameOver();
    }
}

// ============================================================================
// UI OVERLAY
// ============================================================================

const UI = {
    overlay: null,

    init() {
        this.overlay = document.getElementById('ui-overlay');
        this.updateUI();
    },

    updateUI() {
        if (GameState.screen === 'START') {
            this.overlay.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; padding: 20px;">
                    <h1 style="font-size: 52px; color: #4fc3f7; margin-bottom: 10px;">GAP TAG</h1>
                    <p style="font-size: 18px; margin-bottom: 40px; color: #888;">Get your tooth back!</p>

                    <h2 style="font-size: 28px; margin-bottom: 30px;">Select Level</h2>

                    <div style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center;">
                        <!-- Level 1: Chase the Opp -->
                        <div onclick="selectLevel('chase')" style="
                            width: 250px;
                            padding: 30px;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            border-radius: 15px;
                            cursor: pointer;
                            transition: transform 0.2s, box-shadow 0.2s;
                            pointer-events: all;
                            border: 3px solid transparent;
                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 10px 30px rgba(102,126,234,0.5)'"
                           onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                            <div style="font-size: 40px; margin-bottom: 15px;">🏃</div>
                            <h3 style="font-size: 24px; margin-bottom: 10px; color: white;">Chase the Opp</h3>
                            <p style="font-size: 14px; color: #ddd; margin-bottom: 15px;">Catch the enemy while dodging obstacles!</p>
                            <div style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 20px; display: inline-block;">
                                <span style="font-size: 12px; font-weight: bold;">▶ PLAY NOW</span>
                            </div>
                        </div>

                        <!-- Level 2: Animation Testing -->
                        <div onclick="selectLevel('shoot')" style="
                            width: 250px;
                            padding: 30px;
                            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
                            border-radius: 15px;
                            cursor: pointer;
                            transition: transform 0.2s, box-shadow 0.2s;
                            pointer-events: all;
                            border: 3px solid transparent;
                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 10px 30px rgba(33,150,243,0.5)'"
                           onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                            <div style="font-size: 40px; margin-bottom: 15px;">🎬</div>
                            <h3 style="font-size: 24px; margin-bottom: 10px; color: white;">Animation Testing</h3>
                            <p style="font-size: 14px; color: #ddd; margin-bottom: 15px;">Test officer animations on a grid!</p>
                            <div style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 20px; display: inline-block;">
                                <span style="font-size: 12px; font-weight: bold;">▶ TEST NOW</span>
                            </div>
                        </div>
                    </div>

                    <p style="font-size: 14px; color: #666; margin-top: 40px;">Tap LEFT or RIGHT to move • Catch the enemy to score</p>
                </div>
            `;
        } else if (GameState.screen === 'PLAYING') {
            const modeColor = GameState.selectedLevel === 'shoot' ? 'rgba(33, 150, 243, 0.8)' :
                             GameState.currentMode === 'CHASE' ? 'rgba(79, 195, 247, 0.8)' : 'rgba(239, 83, 80, 0.8)';
            const modeText = GameState.selectedLevel === 'shoot' ? '🎬 ANIMATION TESTING' :
                            GameState.currentMode === 'CHASE' ? 'CHASE MODE' : '!!! RUN AWAY !!!';

            // Show controls for testing mode
            const mazeControls = GameState.selectedLevel === 'shoot' ? `
                <div style="position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 15px 25px; border-radius: 10px; color: white; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">Test Officer Animations</div>
                    <div style="font-size: 14px; margin-bottom: 5px;">WASD or Arrow Keys to Move</div>
                    <div style="font-size: 14px; margin-bottom: 5px; color: #ffeb3b;">Number Keys 1-4 to Rotate Manually</div>
                    <div style="font-size: 12px; margin-bottom: 5px; color: #aaa;">1=Forward | 2=Right | 3=Back | 4=Left | 0=Auto</div>
                    <div style="display: flex; gap: 8px; justify-content: center; margin-top: 10px;">
                        <div style="padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 12px;">Move = Run</div>
                        <div style="padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 12px;">Stop = Idle</div>
                    </div>
                </div>
            ` : '';

            this.overlay.innerHTML = `
                <div style="position: absolute; top: 20px; left: 20px; color: white; font-size: 18px;">
                    <div>Score: ${GameState.score}</div>
                    <div style="color: #ffeb3b;">Best: ${GameState.highScore}</div>
                </div>
                <div style="position: absolute; top: 20px; right: 20px; color: white; font-size: 24px;">
                    ${'❤️'.repeat(GameState.lives)}${'🖤'.repeat(GameState.maxLives - GameState.lives)}
                </div>
                <div style="position: absolute; top: 0; left: 0; width: 100%; padding: 10px; text-align: center; background: ${modeColor}; color: white; font-size: 24px; font-weight: bold;">
                    ${modeText}
                </div>
                ${mazeControls}
            `;
        } else if (GameState.screen === 'GAMEOVER') {
            this.overlay.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; background: rgba(0,0,0,0.8);">
                    <h1 style="font-size: 48px; color: #ef5350; margin-bottom: 30px;">GAME OVER</h1>
                    <p style="font-size: 28px; margin-bottom: 10px;">Score: ${GameState.score}</p>
                    ${GameState.isNewHighScore ?
                        '<p style="font-size: 24px; color: #ffeb3b;">NEW HIGH SCORE!</p>' :
                        '<p style="font-size: 18px; color: #888;">Best: ' + GameState.highScore + '</p>'}
                    <p style="font-size: 24px; color: #4fc3f7; margin-top: 60px; pointer-events: all; cursor: pointer;" onclick="resetGame()">TAP TO PLAY AGAIN</p>
                </div>
            `;
        }
    }
};

// ============================================================================
// GAME FLOW
// ============================================================================

function selectLevel(level) {
    GameState.selectedLevel = level;
    console.log('Selected level:', level);

    if (level === 'chase') {
        startGame();
    } else if (level === 'shoot') {
        startShootingGame();
    }
}

function startGame() {
    // Default to chase mode if no level selected
    if (!GameState.selectedLevel) {
        GameState.selectedLevel = 'chase';
    }

    // Remove debug dashboards (only for Animation Testing mode)
    removeDebugDashboard();
    removeStepTrackerDashboard();

    GameState.screen = 'PLAYING';
    GameState.isRunning = true;
    GameState.score = 0;
    GameState.lives = 3;
    PlayerController.init();
    EnemyController.init();
    ObstacleManager.reset();
    UI.updateUI();

    console.log('Starting game with level:', GameState.selectedLevel);
}

function startShootingGame() {
    GameState.selectedLevel = 'shoot';
    GameState.screen = 'PLAYING';
    GameState.isRunning = true;
    GameState.score = 0;
    GameState.lives = 3;

    console.log('Starting Animation Testing mode...');

    // Clear any existing chase mode objects
    if (playerModel) scene.remove(playerModel);
    if (enemyModel) scene.remove(enemyModel);
    obstacles.forEach(obs => obs.deactivate());
    obstacles.length = 0;

    // Clear road segments (simple)
    roadSegments.forEach(segment => {
        scene.remove(segment.mesh);
    });
    roadSegments.length = 0;

    // Clear 3D road models
    roadModels.forEach(roadModel => {
        scene.remove(roadModel);
    });
    roadModels.length = 0;

    // Build the testing ground
    buildTestingGround();

    // RALPH FIX: Don't set hardcoded camera position here
    // Camera will be positioned correctly when tunnel/officer finish loading
    // Initial default camera (will be overridden)
    camera.position.set(0, 8, 15);
    camera.lookAt(0, 0, 0);

    // Load officer character
    loadOfficerCharacter();

    UI.updateUI();

    // RALPH: Create debug dashboards
    createDebugDashboard();
    createStepTrackerDashboard();
}

function gameOver() {
    GameState.screen = 'GAMEOVER';
    GameState.isRunning = false;

    if (GameState.score > GameState.highScore) {
        GameState.highScore = GameState.score;
        GameState.isNewHighScore = true;
        localStorage.setItem('gaptag_highscore', GameState.highScore);
    } else {
        GameState.isNewHighScore = false;
    }

    UI.updateUI();
}

function resetGame() {
    startGame();
}

function loadHighScore() {
    const saved = localStorage.getItem('gaptag_highscore');
    GameState.highScore = saved ? parseInt(saved, 10) : 0;
}

// ============================================================================
// MAIN GAME LOOP
// ============================================================================

function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    // Always update animations so they loop smoothly regardless of game state
    if (playerMixer) playerMixer.update(delta);
    if (enemyMixer) enemyMixer.update(delta);
    if (shooterMixer) shooterMixer.update(delta);

    // Update hazard lights flashing
    updateHazardLights(delta);

    // Apply gun controls every frame for real-time dashboard updates
    if (subMachineGun && GameState.selectedLevel === 'shoot') {
        // Auto-detect officer facing direction and update gun accordingly
        if (shooterModel) {
            const rotation = shooterModel.rotation.y;
            // Normalize rotation to 0-2π range
            const normalizedRotation = ((rotation % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);

            // Determine direction based on rotation (in degrees for clarity)
            const degrees = normalizedRotation * 180 / Math.PI;
            let direction = 'forward';

            // Forward: 315° to 45° (0° ± 45°)
            if (degrees >= 315 || degrees < 45) {
                direction = 'forward';
            }
            // Right: 45° to 135° (90° ± 45°)
            else if (degrees >= 45 && degrees < 135) {
                direction = 'right';
            }
            // Backward: 135° to 225° (180° ± 45°)
            else if (degrees >= 135 && degrees < 225) {
                direction = 'backward';
            }
            // Left: 225° to 315° (270° ± 45°)
            else if (degrees >= 225 && degrees < 315) {
                direction = 'left';
            }

            GunControls.updateForDirection(direction);
        }

        subMachineGun.rotation.set(GunControls.rotationX, GunControls.rotationY, GunControls.rotationZ);
        subMachineGun.position.set(GunControls.positionX, GunControls.positionY, GunControls.positionZ);
        subMachineGun.scale.set(GunControls.scale, GunControls.scale, GunControls.scale);
    }

    if (GameState.screen === 'PLAYING' && GameState.isRunning) {
        // Update score
        GameState.score += Math.floor(delta * 10);

        if (GameState.selectedLevel === 'chase') {
            // CHASE MODE logic
            PlayerController.update(delta);
            EnemyController.update(delta);
            ObstacleManager.update(delta);
            EnvironmentManager.update(delta);
            checkCollisions();

            // Update camera to follow player
            if (playerModel) {
                camera.position.x = playerModel.position.x;
                camera.position.z = playerModel.position.z + 8;
                camera.lookAt(playerModel.position.x, playerModel.position.y + 1, playerModel.position.z - 5);
            }

            // Only update UI for chase mode (score display)
            UI.updateUI();
        } else if (GameState.selectedLevel === 'shoot') {
            // ANIMATION TESTING MODE
            MazeController.update(delta);

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.userData.lifetime += delta;

                // Move bullet
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                // Remove if expired or out of bounds
                if (bullet.userData.lifetime >= bullet.userData.maxLifetime ||
                    Math.abs(bullet.position.x) > 100 ||
                    Math.abs(bullet.position.z) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }

            // Update smoke particles
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const smoke = smokeParticles[i];
                smoke.userData.lifetime += delta;

                // Move smoke
                smoke.position.add(smoke.userData.velocity.clone().multiplyScalar(delta));

                // Expand and fade out
                const lifeProgress = smoke.userData.lifetime / smoke.userData.maxLifetime;
                smoke.scale.setScalar(1 + lifeProgress * 2); // Grow larger
                smoke.material.opacity = 0.6 * (1 - lifeProgress); // Fade out

                // Slow down
                smoke.userData.velocity.multiplyScalar(0.95);

                // Remove if expired
                if (smoke.userData.lifetime >= smoke.userData.maxLifetime) {
                    scene.remove(smoke);
                    smokeParticles.splice(i, 1);
                }
            }

            // Update bullet casings
            const gravity = -9.8;
            const groundLevel = 0.15; // Height of casing cylinder when on ground
            const bounceDamping = 0.4; // Energy loss on bounce

            for (let i = bulletCasings.length - 1; i >= 0; i--) {
                const casing = bulletCasings[i];
                casing.userData.lifetime += delta;

                if (!casing.userData.onGround) {
                    // Apply gravity
                    casing.userData.velocity.y += gravity * delta;

                    // Update position
                    casing.position.add(casing.userData.velocity.clone().multiplyScalar(delta));

                    // Rotate (tumbling)
                    casing.rotation.x += casing.userData.rotationVelocity.x * delta;
                    casing.rotation.y += casing.userData.rotationVelocity.y * delta;
                    casing.rotation.z += casing.userData.rotationVelocity.z * delta;

                    // Check if hit ground
                    if (casing.position.y <= groundLevel) {
                        casing.position.y = groundLevel;

                        // Bounce
                        if (Math.abs(casing.userData.velocity.y) > 0.5) {
                            casing.userData.velocity.y = -casing.userData.velocity.y * bounceDamping;
                            casing.userData.velocity.x *= 0.8;
                            casing.userData.velocity.z *= 0.8;
                            casing.userData.rotationVelocity.multiplyScalar(0.6);
                        } else {
                            // Settled on ground
                            casing.userData.onGround = true;
                            casing.userData.velocity.set(0, 0, 0);
                            casing.userData.rotationVelocity.set(0, 0, 0);
                        }
                    }
                }

                // Remove old casings after 30 seconds
                if (casing.userData.lifetime > 30) {
                    scene.remove(casing);
                    bulletCasings.splice(i, 1);
                }
            }

            // Update car damage system (smoke, fire, bullet collision)
            updateCarDamageSystem(delta);

            // Camera follows character from behind - tunnel runs along Z-axis at Y=-5
            if (shooterModel) {
                const cameraOffsetY = 3;   // Height above character
                const cameraOffsetZ = 6;   // Distance behind character (reduced from 12 for closer view)

                // RALPH FIX: Character now faces toward EXIT (positive Z)
                // So camera should be BEHIND (lower Z) looking FORWARD (higher Z)
                camera.position.set(
                    shooterModel.position.x,
                    shooterModel.position.y + cameraOffsetY,
                    shooterModel.position.z - cameraOffsetZ  // BEHIND = lower Z
                );

                // Look ahead toward the exit (positive Z direction)
                camera.lookAt(
                    shooterModel.position.x,
                    shooterModel.position.y,
                    shooterModel.position.z + 20  // FORWARD = higher Z
                );
            } else {
                // Default camera position
                camera.position.set(0, 8, 15);
                camera.lookAt(0, 0, 0);
            }

            // DO NOT call UI.updateUI() every frame for shoot mode!
            // This would destroy and recreate the gun dashboard sliders,
            // making them impossible to interact with.
            // The UI is set once when starting shoot mode.

            // RALPH: Update debug position dashboard
            updateDebugDashboard();

            // RALPH: Record step tracker data
            stepTracker.record(delta);
        }
    }

    renderer.render(scene, camera);
}

// ============================================================================
// INITIALIZATION
// ============================================================================

function init() {
    console.log('Gap Tag 3D - Initializing...');

    // Create scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // RALPH: Expose scene for debugging
    window.scene = scene;

    // Create camera (3rd person view)
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(0, 6, 8);
    camera.lookAt(0, 0, 0);

    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Enhanced rendering for realistic lighting
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2; // Slightly brighter exposure
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    document.body.appendChild(renderer.domElement);

    // Clock for animations
    clock = new THREE.Clock();

    // Initialize systems
    Input.init();
    UI.init();
    loadHighScore();

    // Check URL parameters - auto-start Animation Testing if collision version specified
    const urlParams = new URLSearchParams(window.location.search);
    let collisionVersion = urlParams.get('v') || urlParams.get('version');

    // DEFAULT: If no parameter, auto-use V2 collision
    if (collisionVersion === null) {
        collisionVersion = '2';
        console.log('🎯 No URL parameter - defaulting to V2 collision');

        // Update URL to show ?v=2
        const url = new URL(window.location);
        url.searchParams.set('v', '2');
        window.history.replaceState({}, '', url);
    }

    // Check if user wants to auto-start a specific mode
    const modeParam = urlParams.get('mode');
    const shouldAutoStart = modeParam === 'test';

    // Always initialize environment and characters for level selection
    EnvironmentManager.init();
    ObstacleManager.init();
    loadPlayerCharacter();
    loadEnemyCharacter();

    // Handle window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Auto-start Animation Testing only if mode=test parameter is present
    if (shouldAutoStart) {
        console.log('🎯 Auto-starting Animation Testing mode (mode=test detected)');
        startShootingGame();
    } else {
        console.log('📋 Showing level selection menu (use ?v=2&mode=test to auto-start Animation Testing)');
    }

    // Start animation loop
    animate();

    console.log('Gap Tag 3D - Ready!');
}

// Make functions global for UI
window.selectLevel = selectLevel;
window.startGame = startGame;
window.resetGame = resetGame;

// Start when ready
if (document.readyState === 'complete') {
    init();
} else {
    window.addEventListener('load', init);
}
