// ============================================================================
// GAP TAG - 3D Endless Runner (Temple Run Style)
// ============================================================================

import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Debug mode
const DEBUG = true;

// ============================================================================
// LEVEL CONFIGURATION - STARTING POSITIONS
// ============================================================================
// IMPORTANT: These are the verified starting positions for each game mode
// DO NOT CHANGE unless explicitly updated by the user

const LEVEL_CONFIG = {
    // ANIMATION TESTING MODE (Tunnel)
    // ⭐ PERFECT SIZE CONFIRMED - 2026-01-24 at 17:37
    // Tunnel scale: (100, 100, 100) - DO NOT CHANGE
    // Starting position: X: -29.05, Z: -200.28 (user's saved position)
    ANIMATION_TESTING_START: {
        x: -29.05,   // User's exact starting X from step tracker screenshot
        y: 1.0,
        z: -200.28,  // User's exact starting Z from step tracker screenshot
        rotation: 0,  // Face toward exit (positive Z direction)
        description: 'Inside tunnel at perfect size - user confirmed'
    }
};

// ============================================================================
// THREE.JS SETUP
// ============================================================================

let scene, camera, renderer;
let player, enemy;
let playerMixer, enemyMixer;
let playerModel, enemyModel;
let clock;

// Game world
const LANE_WIDTH = 3;
const LANE_POSITIONS = [-LANE_WIDTH, 0, LANE_WIDTH];
const GAME_SPEED = 15;

// Shooting game variables (now maze exploration)
let shooterModel, shooterMixer;
let bullets = [];
let enemies = [];
let mazeWalls = [];
let exitMarker = null;

// Urban environment
let urbanEnvironment = null;
let environmentColliders = []; // Collision boxes for environment objects
let debugCollisionBoxes = []; // Visual wireframes for debugging

// Maze layout (1 = wall, 0 = corridor, 2 = exit)
const MAZE_LAYOUT = [
    [1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1]
];

const TILE_SIZE = 3;
const WALL_HEIGHT = 3;

// ============================================================================
// GAME STATE
// ============================================================================

const GameState = {
    isRunning: false,
    isPaused: false,
    isGameOver: false,
    currentMode: 'CHASE',
    score: 0,
    highScore: 0,
    lives: 3,
    maxLives: 3,
    screen: 'START',
    isNewHighScore: false,
    gameSpeed: GAME_SPEED,
    selectedLevel: null // 'chase' or 'brawl'
};

// ============================================================================
// INPUT SYSTEM
// ============================================================================

const Input = {
    touchActive: false,
    touchSide: null,
    touchX: 0,
    touchY: 0,
    inputProcessed: false,
    canvas: null,

    init() {
        console.log('Input system initializing...');

        // CRITICAL FIX: Attach events to canvas element, not document
        // This prevents UI overlays from blocking input events
        // The canvas reference is set after renderer is created
        this.canvas = renderer.domElement;
        this.canvas.id = 'gameCanvas';
        this.canvas.style.touchAction = 'none'; // Prevent browser touch gestures

        // Touch events on canvas with passive: false to allow preventDefault
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
        this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });

        // Mouse events on canvas
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));

        // Keyboard events must stay on document (canvas doesn't receive key events without focus)
        document.addEventListener('keydown', this.handleKeyDown.bind(this));

        // Make canvas focusable for better event handling
        this.canvas.tabIndex = 1;
        this.canvas.style.outline = 'none';

        console.log('Input system initialized! Event listeners attached to canvas:', this.canvas.id);
    },

    handleTouchStart(e) {
        e.preventDefault();
        e.stopPropagation();
        const touch = e.touches[0];
        this.touchX = touch.clientX;
        this.touchY = touch.clientY;
        this.touchActive = true;
        this.touchSide = this.touchX < window.innerWidth / 2 ? 'LEFT' : 'RIGHT';
        console.log('Touch START on canvas: side=' + this.touchSide + ', x=' + this.touchX);
    },

    handleTouchMove(e) {
        // Prevent scrolling/zooming while touching the game canvas
        e.preventDefault();
        e.stopPropagation();
    },

    handleTouchEnd(e) {
        e.preventDefault();
        e.stopPropagation();
        // Don't immediately clear - let game loop process it first
        setTimeout(() => {
            this.touchActive = false;
            this.touchSide = null;
        }, 100);
    },

    handleMouseDown(e) {
        // Only process left mouse button
        if (e.button !== 0) return;

        e.preventDefault();
        e.stopPropagation();

        console.log('Mouse DOWN on canvas:', e.clientX, e.clientY);
        this.touchX = e.clientX;
        this.touchY = e.clientY;
        this.touchActive = true;
        this.touchSide = this.touchX < window.innerWidth / 2 ? 'LEFT' : 'RIGHT';
        console.log('Input.handleMouseDown: touchSide=' + this.touchSide + ', x=' + this.touchX + ', touchActive=' + this.touchActive);
    },

    handleMouseUp(e) {
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();

        // Don't immediately clear - let game loop process it first
        setTimeout(() => {
            this.touchActive = false;
            this.touchSide = null;
        }, 100);
    },

    handleKeyDown(e) {
        if (e.key === 'ArrowLeft') {
            this.touchSide = 'LEFT';
            this.touchActive = true;
            setTimeout(() => { this.touchActive = false; }, 100);
        } else if (e.key === 'ArrowRight') {
            this.touchSide = 'RIGHT';
            this.touchActive = true;
            setTimeout(() => { this.touchActive = false; }, 100);
        }
    }
};

// ============================================================================
// PLAYER CONTROLLER
// ============================================================================

const PlayerController = {
    currentLane: 1,
    targetLane: 1,
    laneChangeSpeed: 10,
    isInvincible: false,
    invincibilityTimer: 0,

    init() {
        this.currentLane = 1;
        this.targetLane = 1;
        this.isInvincible = false;
        this.invincibilityTimer = 0;
    },

    update(dt) {
        // Handle input
        if (Input.touchActive && !Input.inputProcessed) {
            if (Input.touchSide === 'LEFT' && this.targetLane > 0) {
                this.targetLane--;
                Input.inputProcessed = true;
            } else if (Input.touchSide === 'RIGHT' && this.targetLane < 2) {
                this.targetLane++;
                Input.inputProcessed = true;
            }
        }

        if (!Input.touchActive) {
            Input.inputProcessed = false;
        }

        // Smooth lane movement
        if (playerModel) {
            const targetX = LANE_POSITIONS[this.targetLane];
            const diff = targetX - playerModel.position.x;

            if (Math.abs(diff) > 0.01) {
                playerModel.position.x += diff * this.laneChangeSpeed * dt;
            } else {
                playerModel.position.x = targetX;
            }
        }

        // Update invincibility
        if (this.isInvincible) {
            this.invincibilityTimer -= dt;
            if (this.invincibilityTimer <= 0) {
                this.isInvincible = false;
                this.invincibilityTimer = 0;
            }
        }
    }
};

// ============================================================================
// ENEMY CONTROLLER
// ============================================================================

const EnemyController = {
    currentLane: 1,
    targetLane: 1,
    laneChangeSpeed: 8,
    laneChangeTimer: 0,
    laneChangeInterval: 2,
    distanceFromPlayer: -15, // Behind player in chase mode

    init() {
        this.currentLane = 1;
        this.targetLane = 1;
        this.laneChangeTimer = 0;
    },

    update(dt) {
        this.laneChangeTimer += dt;

        if (this.laneChangeTimer >= this.laneChangeInterval) {
            this.laneChangeTimer = 0;
            const rand = Math.random();

            if (rand < 0.33 && this.targetLane > 0) {
                this.targetLane--;
            } else if (rand > 0.66 && this.targetLane < 2) {
                this.targetLane++;
            }

            this.laneChangeInterval = 1.5 + Math.random() * 1.5;
        }

        // Smooth lane movement
        if (enemyModel) {
            const targetX = LANE_POSITIONS[this.targetLane];
            const diff = targetX - enemyModel.position.x;

            if (Math.abs(diff) > 0.01) {
                enemyModel.position.x += diff * this.laneChangeSpeed * dt;
            } else {
                enemyModel.position.x = targetX;
            }

            // Position behind/ahead of player based on mode
            const targetZ = GameState.currentMode === 'CHASE' ? this.distanceFromPlayer : -this.distanceFromPlayer;
            enemyModel.position.z = targetZ;
        }
    }
};

// ============================================================================
// MAZE CONTROLLER (for Maze Exploration mode)
// ============================================================================

const MazeController = {
    velocity: { x: 0, z: 0 },
    speed: 8,
    keysPressed: { up: false, down: false, left: false, right: false },
    manualRotation: null, // For manual direction control

    init() {
        this.velocity = { x: 0, z: 0 };
        this.manualRotation = null;
        console.log('Animation Controller initialized');

        // Add keyboard listeners
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
    },

    handleKeyDown(e) {
        switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                this.keysPressed.up = true;
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                this.keysPressed.down = true;
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                this.keysPressed.left = true;
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                this.keysPressed.right = true;
                break;
            case ' ':
                // Spacebar - shoot
                this.shoot();
                break;

            // MANUAL DIRECTION CONTROLS
            case '1':
                // Face UP (north, toward -Z)
                this.manualRotation = 0;
                console.log('Manual rotation: FORWARD (0°)');
                break;
            case '2':
                // Face RIGHT (east, toward +X)
                this.manualRotation = Math.PI / 2;
                console.log('Manual rotation: RIGHT (90°)');
                break;
            case '3':
                // Face DOWN (south, toward +Z)
                this.manualRotation = Math.PI;
                console.log('Manual rotation: BACKWARD (180°)');
                break;
            case '4':
                // Face LEFT (west, toward -X)
                this.manualRotation = -Math.PI / 2;
                console.log('Manual rotation: LEFT (-90°)');
                break;
            case '0':
                // Clear manual rotation
                this.manualRotation = null;
                console.log('Manual rotation: CLEARED (auto mode)');
                break;
            case 'c':
            case 'C':
                // Toggle collision debug view
                const currentlyVisible = debugCollisionBoxes.length > 0 && debugCollisionBoxes[0].visible;
                toggleCollisionDebug(!currentlyVisible);
                console.log('Collision debug:', !currentlyVisible ? 'ON' : 'OFF');
                break;
        }
    },

    shoot() {
        console.log('BANG! Officer shooting...');

        // Alternate flash color between yellow and white
        if (muzzleFlash) {
            const flashColor = flashColorToggle ? 0xffff00 : 0xffffff; // Yellow or white
            muzzleFlash.material.color.setHex(flashColor);

            // Update point light color too
            if (muzzleFlash.children[0]) {
                muzzleFlash.children[0].color.setHex(flashColor);
            }

            muzzleFlash.visible = true;
            flashColorToggle = !flashColorToggle; // Toggle for next shot

            // Hide after short duration
            setTimeout(() => {
                if (muzzleFlash) muzzleFlash.visible = false;
            }, 50); // 50ms flash
        }

        // Fire bullet projectile
        this.fireBullet();

        // Create smoke particles
        this.createSmokeEffect();

        // Eject bullet casing
        this.ejectBulletCasing();

        // Play shooting animation if available
        if (officerActions.shoot) {
            // Play shoot animation once, then return to previous state
            const previousAnim = officerActions.current;

            if (officerActions[officerActions.current]) {
                officerActions[officerActions.current].fadeOut(0.1);
            }

            officerActions.shoot.reset();
            officerActions.shoot.setLoop(THREE.LoopOnce, 1);
            officerActions.shoot.clampWhenFinished = true;
            officerActions.shoot.fadeIn(0.1);
            officerActions.shoot.play();

            officerActions.current = 'shoot';

            // Return to previous animation after shoot completes
            setTimeout(() => {
                if (officerActions[previousAnim]) {
                    officerActions.shoot.fadeOut(0.1);
                    officerActions[previousAnim].reset().fadeIn(0.1).play();
                    officerActions.current = previousAnim;
                }
            }, officerActions.shoot._clip.duration * 1000);
        }
    },

    createSmokeEffect() {
        if (!subMachineGun) return;

        // Get world position of gun barrel (where muzzle flash is)
        const barrelPos = new THREE.Vector3();
        if (muzzleFlash) {
            muzzleFlash.getWorldPosition(barrelPos);
        } else {
            subMachineGun.getWorldPosition(barrelPos);
        }

        // Create 5-8 smoke particles
        const numParticles = 5 + Math.floor(Math.random() * 4);
        for (let i = 0; i < numParticles; i++) {
            const smokeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const smokeMaterial = new THREE.MeshBasicMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.6
            });
            const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);

            // Position at gun barrel
            smoke.position.copy(barrelPos);

            // Add random velocity (spread outward from gun)
            const spread = 0.5;
            smoke.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * spread,
                Math.random() * 2 + 1, // Upward bias
                -Math.random() * 2 - 1 // Forward (in shooting direction)
            );

            // Rotate velocity based on shooter's rotation
            smoke.userData.velocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), shooterModel.rotation.y);

            smoke.userData.lifetime = 0;
            smoke.userData.maxLifetime = 1.0 + Math.random() * 0.5; // 1-1.5 seconds

            scene.add(smoke);
            smokeParticles.push(smoke);
        }
    },

    fireBullet() {
        if (!muzzleFlash || !shooterModel) return;

        // Get muzzle flash world position (gun barrel tip)
        const barrelPos = new THREE.Vector3();
        muzzleFlash.getWorldPosition(barrelPos);

        // Create bullet (very small silver cylinder/capsule - realistic bullet size)
        const bulletGeometry = new THREE.CapsuleGeometry(0.015, 0.08, 4, 8);
        const bulletMaterial = new THREE.MeshStandardMaterial({
            color: 0xc0c0c0, // Silver color
            metalness: 0.9,
            roughness: 0.1,
            emissive: 0x404040 // Slight glow
        });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Position at gun barrel tip
        bullet.position.copy(barrelPos);

        // Calculate shooting direction (forward from officer's facing direction)
        const shootAngle = shooterModel.rotation.y;
        const bulletSpeed = 50; // Very fast
        bullet.userData.velocity = new THREE.Vector3(
            Math.sin(shootAngle) * bulletSpeed,
            0, // Straight ahead (no drop for now)
            Math.cos(shootAngle) * bulletSpeed
        );

        // Orient bullet in direction of travel
        bullet.rotation.x = Math.PI / 2; // Point capsule forward
        bullet.rotation.y = shootAngle;

        bullet.userData.lifetime = 0;
        bullet.userData.maxLifetime = 3; // 3 seconds max range

        scene.add(bullet);
        bullets.push(bullet);

        console.log('Bullet fired!');
    },

    ejectBulletCasing() {
        if (!subMachineGun || !shooterModel) return;

        // Get gun position in world space
        const gunPos = new THREE.Vector3();
        subMachineGun.getWorldPosition(gunPos);

        // Create bullet casing (very small cylinder - realistic shell casing size)
        const casingGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.04, 8);
        const casingMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37, // Golden brass color
            metalness: 0.8,
            roughness: 0.2
        });
        const casing = new THREE.Mesh(casingGeometry, casingMaterial);
        casing.castShadow = true;

        // Position at gun (slightly to the right for ejection port)
        casing.position.copy(gunPos);
        casing.position.y += 0.5; // Slightly higher

        // Ejection velocity (to the right and up)
        const ejectSpeed = 3;
        const ejectAngle = shooterModel.rotation.y + Math.PI / 2; // 90 degrees right
        casing.userData.velocity = new THREE.Vector3(
            Math.cos(ejectAngle) * ejectSpeed + (Math.random() - 0.5),
            2 + Math.random(), // Upward
            Math.sin(ejectAngle) * ejectSpeed + (Math.random() - 0.5)
        );

        // Random rotation velocity for tumbling effect
        casing.userData.rotationVelocity = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
        );

        casing.userData.onGround = false;
        casing.userData.lifetime = 0;

        scene.add(casing);
        bulletCasings.push(casing);
    },

    handleKeyUp(e) {
        switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                this.keysPressed.up = false;
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                this.keysPressed.down = false;
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                this.keysPressed.left = false;
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                this.keysPressed.right = false;
                break;
        }
    },

    update(delta) {
        if (!shooterModel) return;

        // Calculate velocity based on key presses
        this.velocity.x = 0;
        this.velocity.z = 0;

        // RALPH FIX: Tunnel now runs entrance (low Z) to exit (high Z)
        // So forward = positive Z (toward exit)
        if (this.keysPressed.up) this.velocity.z += this.speed;  // W moves forward (positive Z - toward exit)
        if (this.keysPressed.down) this.velocity.z -= this.speed; // S moves backward (negative Z - toward entrance)
        // RALPH FIX: Corrected left/right - tunnel rotated 90°, so X is flipped
        if (this.keysPressed.left) this.velocity.x -= this.speed; // A moves left (negative X)
        if (this.keysPressed.right) this.velocity.x += this.speed; // D moves right (positive X)

        // Normalize diagonal movement
        if (this.velocity.x !== 0 && this.velocity.z !== 0) {
            const factor = 1 / Math.sqrt(2);
            this.velocity.x *= factor;
            this.velocity.z *= factor;
        }

        // Calculate new position
        const newX = shooterModel.position.x + this.velocity.x * delta;
        const newZ = shooterModel.position.z + this.velocity.z * delta;

        // Check collision with environment
        const characterRadius = 0.5; // Officer collision radius
        if (!checkEnvironmentCollision(newX, newZ, characterRadius)) {
            // No collision - update position
            shooterModel.position.x = newX;
            shooterModel.position.z = newZ;
        } else {
            // Collision detected - try sliding along walls
            // Try X movement only
            if (!checkEnvironmentCollision(newX, shooterModel.position.z, characterRadius)) {
                shooterModel.position.x = newX;
            }
            // Try Z movement only
            if (!checkEnvironmentCollision(shooterModel.position.x, newZ, characterRadius)) {
                shooterModel.position.z = newZ;
            }
        }

        // Keep within bounds - allow full tunnel traversal
        const maxBound = 250; // Increased to accommodate tunnel (extends to ±200)
        shooterModel.position.x = Math.max(-maxBound, Math.min(maxBound, shooterModel.position.x));
        shooterModel.position.z = Math.max(-maxBound, Math.min(maxBound, shooterModel.position.z));

        // Check if character is moving
        const isMoving = this.velocity.x !== 0 || this.velocity.z !== 0;

        // Rotate character - use manual rotation if set, otherwise use movement direction
        if (this.manualRotation !== null) {
            // Manual rotation mode (use number keys 1-4)
            shooterModel.rotation.y = this.manualRotation;
        } else if (isMoving) {
            // Auto rotation based on movement direction
            const angle = Math.atan2(this.velocity.x, this.velocity.z);
            shooterModel.rotation.y = angle;
        }

        // Switch between idle and run animations
        this.updateAnimation(isMoving);
    },

    updateAnimation(isMoving) {
        // Don't interrupt shooting animation
        if (officerActions.current === 'shoot') return;

        // Determine animation based on movement
        const targetAnim = isMoving ? 'run' : 'idle';

        // Switch animations with smooth cross-fade
        if (officerActions.current !== targetAnim && officerActions[targetAnim]) {
            // Fade out current animation
            if (officerActions[officerActions.current]) {
                officerActions[officerActions.current].fadeOut(0.3);
            }

            // Fade in new animation
            officerActions[targetAnim].reset().fadeIn(0.3).play();
            officerActions.current = targetAnim;
        }
    }
};


// ============================================================================
// OBSTACLES
// ============================================================================

const obstacles = [];
const obstaclePool = [];

class Obstacle {
    constructor() {
        const geometry = new THREE.BoxGeometry(1.5, 2, 1.5);
        const material = new THREE.MeshLambertMaterial({ color: 0x66bb6a });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.active = false;
        this.lane = 0;
    }

    activate(lane, zPosition) {
        this.lane = lane;
        this.mesh.position.x = LANE_POSITIONS[lane];
        this.mesh.position.y = 1;
        this.mesh.position.z = zPosition;
        this.active = true;
        scene.add(this.mesh);
    }

    deactivate() {
        this.active = false;
        scene.remove(this.mesh);
    }

    update(dt) {
        if (this.active) {
            this.mesh.position.z += GameState.gameSpeed * dt;

            // Remove if behind camera
            if (this.mesh.position.z > 10) {
                this.deactivate();
            }
        }
    }
}

const ObstacleManager = {
    spawnTimer: 0,
    spawnInterval: 1.5,

    init() {
        for (let i = 0; i < 20; i++) {
            obstaclePool.push(new Obstacle());
        }
    },

    spawn() {
        const obstacle = obstaclePool.find(o => !o.active);
        if (obstacle) {
            const lane = Math.floor(Math.random() * 3);
            obstacle.activate(lane, -50);
            obstacles.push(obstacle);
        }
    },

    update(dt) {
        this.spawnTimer += dt;

        if (this.spawnTimer >= this.spawnInterval) {
            this.spawnTimer = 0;
            this.spawn();
        }

        obstacles.forEach(obs => obs.update(dt));
    },

    reset() {
        obstacles.forEach(obs => obs.deactivate());
        obstacles.length = 0;
        this.spawnTimer = 0;
    }
};

// ============================================================================
// ENVIRONMENT (Road/Path)
// ============================================================================

const roadSegments = [];
let roadModels = []; // Array to hold 3D road model instances
let roadModelTemplate = null; // Loaded GLB template to clone

class RoadSegment {
    constructor(zPosition) {
        const geometry = new THREE.PlaneGeometry(15, 20);
        const material = new THREE.MeshLambertMaterial({
            color: 0x404040,
            side: THREE.DoubleSide
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.x = -Math.PI / 2;
        this.mesh.position.y = 0;
        this.mesh.position.z = zPosition;
        this.mesh.receiveShadow = true;
        scene.add(this.mesh);

        // Lane markers
        this.createLaneMarkers(zPosition);
    }

    createLaneMarkers(zPosition) {
        const markerGeometry = new THREE.BoxGeometry(0.2, 0.1, 2);
        const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

        // Left lane marker
        const leftMarker = new THREE.Mesh(markerGeometry, markerMaterial);
        leftMarker.position.set(-LANE_WIDTH / 2, 0.05, zPosition);
        scene.add(leftMarker);

        // Right lane marker
        const rightMarker = new THREE.Mesh(markerGeometry, markerMaterial);
        rightMarker.position.set(LANE_WIDTH / 2, 0.05, zPosition);
        scene.add(rightMarker);
    }

    update(dt) {
        this.mesh.position.z += GameState.gameSpeed * dt;

        if (this.mesh.position.z > 20) {
            this.mesh.position.z -= 60;
        }
    }
}

const EnvironmentManager = {
    init() {
        // Load 3D road model first
        this.loadRoadModel();

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Fog for depth
        scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);
    },

    loadRoadModel() {
        console.log('Loading 3D road model...');

        const loader = new GLTFLoader();

        loader.load(
            'road-street.glb',
            // onLoad
            (gltf) => {
                roadModelTemplate = gltf.scene;

                console.log('Road model loaded successfully');

                // Calculate bounding box to understand size
                const box = new THREE.Box3().setFromObject(roadModelTemplate);
                const size = box.getSize(new THREE.Vector3());
                console.log('Road model size:', {
                    x: size.x.toFixed(2),
                    y: size.y.toFixed(2),
                    z: size.z.toFixed(2)
                });

                // Create multiple road segments
                this.createRoadSegments();
            },
            // onProgress
            (xhr) => {
                if (xhr.lengthComputable) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                    console.log('Road loading: ' + percent + '%');
                }
            },
            // onError
            (error) => {
                console.error('Error loading road model:', error);
                // Fallback to simple road segments
                this.createFallbackRoad();
            }
        );
    },

    createRoadSegments() {
        // Create 3 repeating road segments
        for (let i = 0; i < 3; i++) {
            const roadClone = roadModelTemplate.clone();

            // Position road segments in sequence
            roadClone.position.set(0, 0, -20 * i);

            // Enable shadows
            roadClone.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(roadClone);
            roadModels.push(roadClone);
        }

        console.log('Created', roadModels.length, 'road segments');
    },

    createFallbackRoad() {
        // Fallback to simple road if GLB fails to load
        console.log('Using fallback simple road');
        for (let i = 0; i < 3; i++) {
            roadSegments.push(new RoadSegment(-20 * i));
        }
    },

    update(dt) {
        // Update 3D road models
        roadModels.forEach(roadModel => {
            roadModel.position.z += GameState.gameSpeed * dt;

            // Loop back when road goes too far
            if (roadModel.position.z > 20) {
                roadModel.position.z -= 60;
            }
        });

        // Update fallback road segments if they exist
        roadSegments.forEach(segment => segment.update(dt));
    }
};

// ============================================================================
// CHARACTER LOADING
// ============================================================================

function loadPlayerCharacter() {
    const loader = new FBXLoader();

    loader.load('Fast Run.fbx', (fbx) => {
        playerModel = fbx;
        playerModel.scale.set(0.01, 0.01, 0.01);
        playerModel.position.set(0, 1.0, 0); // Lifted up by 1 unit so feet are on ground
        playerModel.rotation.y = Math.PI;

        playerModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // Keep original material with textures
            }
        });

        scene.add(playerModel);

        // Setup animation with proper looping
        playerMixer = new THREE.AnimationMixer(playerModel);
        if (fbx.animations && fbx.animations.length > 0) {
            const clip = fbx.animations[0];

            // === DEBUG: Log animation data ===
            console.log('=== PLAYER Animation Debug Info ===');
            console.log('Clip name:', clip.name);
            console.log('Clip duration:', clip.duration);
            console.log('Number of tracks:', clip.tracks.length);

            if (clip.tracks.length > 0) {
                const firstTrack = clip.tracks[0];
                console.log('First track name:', firstTrack.name);
                console.log('First track times (first 5):', firstTrack.times.slice(0, 5));
                console.log('First track times (last 5):', firstTrack.times.slice(-5));
                console.log('Min time:', Math.min(...firstTrack.times));
                console.log('Max time:', Math.max(...firstTrack.times));
            }

            // === SOLUTION: Normalize track times (remove timeline offset) ===
            let minTime = Infinity;
            clip.tracks.forEach(track => {
                const trackMinTime = track.times[0];
                if (trackMinTime < minTime) {
                    minTime = trackMinTime;
                }
            });

            // Normalize all track times to start at 0
            if (minTime > 0.001) { // Only normalize if there's a significant offset
                console.log('PLAYER: Normalizing animation - removing offset of:', minTime);
                clip.tracks.forEach(track => {
                    for (let i = 0; i < track.times.length; i++) {
                        track.times[i] -= minTime;
                    }
                });
                // Recalculate duration
                clip.duration = clip.tracks.reduce((max, track) => {
                    return Math.max(max, track.times[track.times.length - 1]);
                }, 0);
                console.log('PLAYER: New duration after normalization:', clip.duration);
            }

            // === RALPH'S FIX: Remove the Hips position track that causes flashing ===
            console.log('PLAYER: Filtering animation tracks...');
            const originalTrackCount = clip.tracks.length;
            clip.tracks = clip.tracks.filter(track => {
                // Remove ONLY the root Hips position track
                // This track moves the character in world space, causing visual glitches when looping
                if (track.name === 'mixamorigHips.position') {
                    console.log('PLAYER: ❌ Removing:', track.name);
                    return false;
                }
                return true; // Keep all rotation tracks
            });
            console.log(`PLAYER: Removed ${originalTrackCount - clip.tracks.length} track(s), kept ${clip.tracks.length}`);

            // === SOLUTION: Try using original clip without subclip first ===
            const action = playerMixer.clipAction(clip);
            action.setLoop(THREE.LoopRepeat, Infinity);
            action.clampWhenFinished = false;
            action.timeScale = 1.0; // Normal speed
            action.reset();
            action.play();
            console.log('PLAYER: Animation playing with normalized clip, duration:', clip.duration);
        }

        console.log('Player character loaded');
    }, undefined, (error) => {
        console.error('Error loading player FBX:', error);
        // Fallback to simple cube
        createFallbackPlayer();
    });
}

function createFallbackPlayer() {
    const geometry = new THREE.BoxGeometry(1, 2, 1);
    const material = new THREE.MeshLambertMaterial({ color: 0x4fc3f7 });
    playerModel = new THREE.Mesh(geometry, material);
    playerModel.position.set(0, 1.0, 0);
    playerModel.castShadow = true;
    scene.add(playerModel);
}

function loadEnemyCharacter() {
    const loader = new FBXLoader();

    loader.load('Fast Run.fbx', (fbx) => {
        enemyModel = fbx;
        enemyModel.scale.set(0.01, 0.01, 0.01);
        enemyModel.position.set(0, 1.0, -15); // Lifted up by 1 unit so feet are on ground
        enemyModel.rotation.y = Math.PI;

        enemyModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                // Keep original material with textures
            }
        });

        scene.add(enemyModel);

        // Setup animation with proper looping
        enemyMixer = new THREE.AnimationMixer(enemyModel);
        if (fbx.animations && fbx.animations.length > 0) {
            const clip = fbx.animations[0];

            // === DEBUG: Log animation data ===
            console.log('=== ENEMY Animation Debug Info ===');
            console.log('Clip name:', clip.name);
            console.log('Clip duration:', clip.duration);
            console.log('Number of tracks:', clip.tracks.length);

            if (clip.tracks.length > 0) {
                const firstTrack = clip.tracks[0];
                console.log('First track name:', firstTrack.name);
                console.log('First track times (first 5):', firstTrack.times.slice(0, 5));
                console.log('First track times (last 5):', firstTrack.times.slice(-5));
                console.log('Min time:', Math.min(...firstTrack.times));
                console.log('Max time:', Math.max(...firstTrack.times));
            }

            // Normalize all track times to start at 0
            if (minTime > 0.001) { // Only normalize if there's a significant offset
                console.log('ENEMY: Normalizing animation - removing offset of:', minTime);
                clip.tracks.forEach(track => {
                    for (let i = 0; i < track.times.length; i++) {
                        track.times[i] -= minTime;
                    }
                });
                // Recalculate duration
                clip.duration = clip.tracks.reduce((max, track) => {
                    return Math.max(max, track.times[track.times.length - 1]);
                }, 0);
                console.log('ENEMY: New duration after normalization:', clip.duration);
            }

            // === RALPH'S FIX: Remove the Hips position track that causes flashing ===
            console.log('ENEMY: Filtering animation tracks...');
            const originalTrackCount = clip.tracks.length;
            clip.tracks = clip.tracks.filter(track => {
                // Remove ONLY the root Hips position track
                if (track.name === 'mixamorigHips.position') {
                    console.log('ENEMY: ❌ Removing:', track.name);
                    return false;
                }
                return true; // Keep all rotation tracks
            });
            console.log(`ENEMY: Removed ${originalTrackCount - clip.tracks.length} track(s), kept ${clip.tracks.length}`);

            // === SOLUTION: Try using original clip without subclip first ===
            const action = enemyMixer.clipAction(clip);
            action.setLoop(THREE.LoopRepeat, Infinity);
            action.clampWhenFinished = false;
            action.timeScale = 1.0; // Normal speed
            action.reset();
            action.play();
            console.log('ENEMY: Animation playing with normalized clip, duration:', clip.duration);
        }

        console.log('Enemy character loaded');
    }, undefined, (error) => {
        console.error('Error loading enemy FBX:', error);
        // Fallback to simple cube
        createFallbackEnemy();
    });
}

function createFallbackEnemy() {
    const geometry = new THREE.BoxGeometry(1, 2, 1);
    const material = new THREE.MeshLambertMaterial({ color: 0xef5350 });
    enemyModel = new THREE.Mesh(geometry, material);
    enemyModel.position.set(0, 1.0, -15);
    enemyModel.castShadow = true;
    scene.add(enemyModel);
}

// ============================================================================
// SHOOTING GAME - OFFICER CHARACTER
// ============================================================================

// Officer animation actions
let officerActions = {
    idle: null,
    run: null,
    shoot: null,
    current: null
};

// Submachine gun model
let subMachineGun = null;
let muzzleFlash = null; // Yellow flash at gun tip
let smokeParticles = []; // Smoke particles from gun
let bulletCasings = []; // Shell casings on ground
let flashColorToggle = true; // Alternate between yellow and white

// Gun rotation controls for dashboard
// Settings for different facing directions
const GunConfigs = {
    // Officer facing RIGHT (positive X direction, 90°)
    right: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    },
    // Officer facing LEFT (negative X direction, 270°/-90°)
    left: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    },
    // Officer facing FORWARD/UP (negative Z direction, 0°)
    forward: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    },
    // Officer facing BACKWARD/DOWN (positive Z direction, 180°)
    backward: {
        rotationX: -10 * Math.PI / 180,  // -10°
        rotationY: 180 * Math.PI / 180,   // 180°
        rotationZ: 85 * Math.PI / 180,    // 85°
        positionX: -15.0,
        positionY: 31.5,
        positionZ: 1.0,
        scale: 0.25,
    }
};

const GunControls = {
    rotationX: -10 * Math.PI / 180,  // -10°
    rotationY: 180 * Math.PI / 180,   // 180°
    rotationZ: 85 * Math.PI / 180,    // 85°
    positionX: -15.0,
    positionY: 31.5,
    positionZ: 1.0,
    scale: 0.25,
    currentDirection: 'right',  // Track current direction

    updateForDirection(direction) {
        // Update gun settings based on officer's facing direction
        if (direction !== this.currentDirection) {
            const config = GunConfigs[direction];
            if (config) {
                this.rotationX = config.rotationX;
                this.rotationY = config.rotationY;
                this.rotationZ = config.rotationZ;
                this.positionX = config.positionX;
                this.positionY = config.positionY;
                this.positionZ = config.positionZ;
                this.scale = config.scale;
                this.currentDirection = direction;
                console.log('Gun config switched to:', direction);
            }
        }
    },

    applyRotation() {
        if (subMachineGun) {
            subMachineGun.rotation.set(this.rotationX, this.rotationY, this.rotationZ);
            subMachineGun.position.set(this.positionX, this.positionY, this.positionZ);
            subMachineGun.scale.set(this.scale, this.scale, this.scale);
        }
    },

    reset() {
        this.rotationX = -10 * Math.PI / 180;  // -10°
        this.rotationY = 180 * Math.PI / 180;   // 180°
        this.rotationZ = 85 * Math.PI / 180;    // 85°
        this.positionX = -15.0;
        this.positionY = 31.5;
        this.positionZ = 1.0;
        this.scale = 0.25;
        this.applyRotation();
    }
};

function loadSubMachineGun() {
    if (!shooterModel) {
        console.error('Cannot load gun: officer model not loaded yet');
        return;
    }

    const loader = new GLTFLoader();

    console.log('Loading M4A1 rifle...');

    loader.load(
        'm4a1/scene.gltf',
        // onLoad
        (gltf) => {
            console.log('M4A1 loaded successfully');

            subMachineGun = gltf.scene;

            // Scale the gun much smaller to match officer hands
            subMachineGun.scale.set(0.15, 0.15, 0.15);

            // Enable shadows on all meshes
            subMachineGun.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Find the right hand bone
            let rightHand = null;
            shooterModel.traverse((child) => {
                if (child.isBone && child.name === 'mixamorigRightHand') {
                    rightHand = child;
                    console.log('Found right hand bone:', child.name);
                }
            });

            if (rightHand) {
                // Attach gun to right hand bone
                rightHand.add(subMachineGun);

                // Position and rotation - these values worked before
                subMachineGun.position.set(0, -2, -5);
                subMachineGun.rotation.set(-Math.PI / 2, 0, 0);

                console.log('M4A1 attached to right hand');
            } else {
                console.warn('Right hand bone not found, adding gun to officer model');
                shooterModel.add(subMachineGun);
                subMachineGun.position.set(0.5, 1.2, 0);
            }

            // Create muzzle flash - bright sphere at gun barrel tip
            const flashGeometry = new THREE.SphereGeometry(3, 12, 12);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // Bright yellow (will alternate with white)
                transparent: true,
                opacity: 1.0
            });
            muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);

            // Position at gun barrel tip (nozzle)
            muzzleFlash.position.set(0, 0, -40); // Forward along gun barrel at nozzle

            // Add bright point light for glow effect
            const flashLight = new THREE.PointLight(0xffff00, 5, 80);
            muzzleFlash.add(flashLight);

            // Attach to gun
            subMachineGun.add(muzzleFlash);

            // Start invisible
            muzzleFlash.visible = false;

            console.log('Muzzle flash created at barrel tip');

        },
        // onProgress
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                console.log('M4A1 loading: ' + percent + '%');
            }
        },
        // onError
        (error) => {
            console.error('Error loading M4A1:', error);
        }
    );
}

function loadOfficerCharacter() {
    const loader = new FBXLoader();

    console.log('Loading Officer character for Maze mode...');

    // Load the Officer model first
    loader.load('Officer.fbx', (fbx) => {
        shooterModel = fbx;
        shooterModel.scale.set(0.01, 0.01, 0.01);
        // Position will be set after tunnel loads - use temp position for now
        shooterModel.position.set(0, 1.0, 0);
        shooterModel.rotation.y = Math.PI; // Face forward down the tunnel (toward positive Z)

        console.log('Officer loaded at position:', shooterModel.position.x, shooterModel.position.z);

        // Keep original textures
        shooterModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        scene.add(shooterModel);

        // Expose shooterModel to window for debugging/testing
        window.shooterModel = shooterModel;

        // RALPH FIX: If tunnel already loaded, position officer inside it now
        if (urbanEnvironment) {
            console.log('Officer loaded AFTER tunnel - positioning now...');

            // Use configured starting position
            const startPos = LEVEL_CONFIG.ANIMATION_TESTING_START;

            shooterModel.position.set(startPos.x, startPos.y, startPos.z);
            shooterModel.rotation.y = startPos.rotation;

            camera.position.set(startPos.x, startPos.y + 3, startPos.z - 8);
            camera.lookAt(startPos.x, startPos.y + 0.5, startPos.z + 10);

            console.log('Officer positioned at STARTING POINT:', startPos.description);
            console.log('Position - X=' + startPos.x.toFixed(2) + ', Y=' + startPos.y.toFixed(2) + ', Z=' + startPos.z.toFixed(2));
        } else {
            console.log('Officer loaded BEFORE tunnel - will be positioned when tunnel loads');
        }

        // Load submachine gun and attach to hand
        loadSubMachineGun();

        // Setup animation mixer
        shooterMixer = new THREE.AnimationMixer(shooterModel);

        // Load multiple animations
        let animationsLoaded = 0;
        const totalAnimations = 3; // run, idle, shoot

        function checkAllAnimationsLoaded() {
            animationsLoaded++;
            if (animationsLoaded === totalAnimations) {
                // Start with idle animation
                if (officerActions.idle) {
                    officerActions.idle.play();
                    officerActions.current = 'idle';
                }

                // Initialize maze controller
                MazeController.init();
                console.log('Officer ready with animations!');
            }
        }

        // Load Rifle Run animation
        loader.load('Rifle Run.fbx', (animFbx) => {
            if (animFbx.animations && animFbx.animations.length > 0) {
                const clip = animFbx.animations[0];

                console.log('=== OFFICER RUN Animation ===');
                console.log('Duration:', clip.duration);

                // Remove position track
                clip.tracks = clip.tracks.filter(track => track.name !== 'mixamorigHips.position');

                // Create action
                officerActions.run = shooterMixer.clipAction(clip);
                officerActions.run.setLoop(THREE.LoopRepeat, Infinity);

                console.log('Run animation loaded');
            }
            checkAllAnimationsLoaded();
        }, undefined, (error) => {
            console.error('Error loading Rifle Run:', error);
            checkAllAnimationsLoaded();
        });

        // Load Rifle Idle animation
        loader.load('Rifle Idle.fbx', (animFbx) => {
            if (animFbx.animations && animFbx.animations.length > 0) {
                const clip = animFbx.animations[0];

                console.log('=== OFFICER IDLE Animation ===');
                console.log('Duration:', clip.duration);

                // Remove position track
                clip.tracks = clip.tracks.filter(track => track.name !== 'mixamorigHips.position');

                // Create action
                officerActions.idle = shooterMixer.clipAction(clip);
                officerActions.idle.setLoop(THREE.LoopRepeat, Infinity);

                console.log('Idle animation loaded');
            }
            checkAllAnimationsLoaded();
        }, undefined, (error) => {
            console.error('Error loading Rifle Idle:', error);
            checkAllAnimationsLoaded();
        });

        // Load Shooting animation
        loader.load('Rifle Shooting.fbx', (animFbx) => {
            if (animFbx.animations && animFbx.animations.length > 0) {
                const clip = animFbx.animations[0];

                console.log('=== OFFICER SHOOT Animation ===');
                console.log('Duration:', clip.duration);

                // Remove position track
                clip.tracks = clip.tracks.filter(track => track.name !== 'mixamorigHips.position');

                // Create action
                officerActions.shoot = shooterMixer.clipAction(clip);
                officerActions.shoot.setLoop(THREE.LoopOnce, 1);
                officerActions.shoot.clampWhenFinished = true;

                console.log('Shoot animation loaded');
            }
            checkAllAnimationsLoaded();
        }, undefined, (error) => {
            console.error('Error loading Rifle Shooting:', error);
            checkAllAnimationsLoaded();
        });

    }, undefined, (error) => {
        console.error('Error loading Officer model:', error);

        // Create a fallback character
        const geometry = new THREE.CapsuleGeometry(0.4, 1.2, 8, 16);
        const material = new THREE.MeshLambertMaterial({ color: 0x2196f3 });
        shooterModel = new THREE.Mesh(geometry, material);
        shooterModel.position.set(TILE_SIZE * 1.5, 1.0, TILE_SIZE * 1.5);
        shooterModel.castShadow = true;
        scene.add(shooterModel);

        // Initialize maze controller with fallback
        MazeController.init();

        console.log('Created fallback character (Officer load failed)');
    });
}

// ============================================================================
// MAZE BUILDING
// ============================================================================

function buildTestingGround() {
    console.log('Building testing ground...');

    // Clear any existing elements
    mazeWalls.forEach(wall => scene.remove(wall));
    mazeWalls = [];
    if (exitMarker) scene.remove(exitMarker);

    // Skip creating test floor - tunnel environment has its own floor
    console.log('Skipping test floor - using tunnel road surface');

    // Load urban environment
    loadUrbanEnvironment();
}

// ============================================================================
// URBAN ENVIRONMENT LOADING
// ============================================================================

function setupUrbanLighting() {
    console.log('Setting up tunnel lighting...');

    // DAYLIGHT - Bright sky blue background
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = null; // No fog

    // BRIGHT DAYLIGHT LIGHTING
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfffacd, 2.0);
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -200;
    sunLight.shadow.camera.right = 200;
    sunLight.shadow.camera.top = 200;
    sunLight.shadow.camera.bottom = -200;
    scene.add(sunLight);

    // RALPH: Floor will be created AFTER tunnel loads to match exact tunnel position

    console.log('Tunnel lighting setup complete');
}

function loadUrbanEnvironment() {
    console.log('Loading tunnel road environment...');

    // Setup atmospheric lighting first
    setupUrbanLighting();

    const loader = new GLTFLoader();

    loader.load(
        'tunnel-road.glb',
        // onLoad
        (gltf) => {
            urbanEnvironment = gltf.scene;

            // STEP TRACKER DATA:
            // User walked X: -38.11 to +10.93 (about 49 units)
            // User walked Z: -208.07 to +189.46 (about 397 units)
            // User's starting position: X: -29.05, Z: -200.28
            //
            // Original scale (80, 80, 15) was too small:
            //   - Visual walls around X=+/-3 didn't contain user at X=-29
            //   - Z from -198 to +198 put user at Z=-200 just outside
            //
            // ⭐ PERFECT SIZE - User confirmed 2026-01-24 at 17:37
            // DO NOT CHANGE THIS SCALE - This is the ideal tunnel size
            urbanEnvironment.scale.set(100, 100, 100);  // PERFECT TUNNEL SIZE
            urbanEnvironment.position.set(-13.5, 0, 0); // Shift left to center user's asymmetric path

            // Rotate on Y-axis to change from horizontal to extending forward/backward
            urbanEnvironment.rotation.x = 0;
            urbanEnvironment.rotation.y = Math.PI / 2; // Rotate 90 degrees to extend along Z-axis
            urbanEnvironment.rotation.z = 0;

            console.log('Tunnel positioned at:', urbanEnvironment.position);
            console.log('Tunnel rotation:', urbanEnvironment.rotation);
            console.log('Tunnel scale:', urbanEnvironment.scale);

            // RALPH: Remove built-in floor texture
            console.log('=== TUNNEL MODEL MESH ANALYSIS ===');
            urbanEnvironment.traverse((child) => {
                if (child.isMesh) {
                    const bbox = new THREE.Box3().setFromObject(child);
                    const size = bbox.getSize(new THREE.Vector3());

                    console.log('MESH:', child.name || 'unnamed');
                    console.log('  Type:', child.type);
                    console.log('  Size:', size.x.toFixed(2), 'x', size.y.toFixed(2), 'x', size.z.toFixed(2));
                    console.log('  Position:', child.position.x.toFixed(2), child.position.y.toFixed(2), child.position.z.toFixed(2));
                    console.log('  Material:', child.material?.type || 'none');
                    console.log('---');

                    // TUNNEL VISIBILITY FIX: Keep original texture but enable DoubleSide
                    if (child.material) {
                        // Clone material to avoid modifying shared material
                        child.material = child.material.clone();
                        child.material.side = THREE.DoubleSide;  // Render both sides for visibility
                        console.log('Tunnel material: kept original texture, enabled DoubleSide for:', child.name);
                    }

                    // Setup shadows
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(urbanEnvironment);

            console.log('Tunnel road loaded');

            // RALPH: NARROW floor strip - like a red carpet runway
            const box = new THREE.Box3().setFromObject(urbanEnvironment);

            // FIX: Adjust tunnel Y position so its floor is at Y=0
            // The tunnel model's geometry has its floor at some positive Y value
            // which gets scaled by 800, putting the tunnel way above the character
            const tunnelMinY = box.min.y;
            const tunnelMaxY = box.max.y;
            console.log('=== TUNNEL Y BOUNDS BEFORE ADJUSTMENT ===');
            console.log('Tunnel min Y (floor):', tunnelMinY.toFixed(2));
            console.log('Tunnel max Y (ceiling):', tunnelMaxY.toFixed(2));
            console.log('Tunnel height:', (tunnelMaxY - tunnelMinY).toFixed(2));

            // Move the tunnel down so its floor (minY) is at Y=0
            // This puts the character INSIDE the tunnel instead of below it
            urbanEnvironment.position.y = -tunnelMinY;
            console.log('Adjusted tunnel Y position to:', urbanEnvironment.position.y.toFixed(2));

            // Recompute bounding box after Y adjustment
            const boxAfter = new THREE.Box3().setFromObject(urbanEnvironment);
            console.log('=== TUNNEL Y BOUNDS AFTER ADJUSTMENT ===');
            console.log('Tunnel min Y (floor):', boxAfter.min.y.toFixed(2));
            console.log('Tunnel max Y (ceiling):', boxAfter.max.y.toFixed(2));

            const tunnelMinZ = boxAfter.min.z;
            const tunnelMaxZ = boxAfter.max.z;
            const tunnelLength = tunnelMaxZ - tunnelMinZ;
            const tunnelCenterZ = (tunnelMinZ + tunnelMaxZ) / 2;

            // ⭐ STAGE 1: Add checkered pattern to tunnel floor using simple PlaneGeometry
            console.log('🎯 Creating simple checkered floor plane...');

            // Create checkered texture (yellow/black pattern)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Yellow squares
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(0, 0, 32, 32);
            ctx.fillRect(32, 32, 32, 32);

            // Black squares
            ctx.fillStyle = '#000000';
            ctx.fillRect(32, 0, 32, 32);
            ctx.fillRect(0, 32, 32, 32);

            const checkeredTexture = new THREE.CanvasTexture(canvas);
            checkeredTexture.wrapS = THREE.RepeatWrapping;
            checkeredTexture.wrapT = THREE.RepeatWrapping;
            checkeredTexture.repeat.set(20, 50);  // 20 checkers wide, 50 long

            // REMOVED OLD COMPLEX EXTRACTION - NOW USING SIMPLE PLANE
                if (child.isMesh && child.name.includes('tunnel')) {
                    console.log('🔍 Analyzing tunnel geometry for floor extraction...');

                    const geometry = child.geometry;
                    const position = geometry.attributes.position;
                    const index = geometry.index;

                    // Get child's world matrix to transform vertices
                    child.updateMatrixWorld(true);
                    const worldMatrix = child.matrixWorld;

                    // Find X range of ALL vertices for road boundary calculation
                    let allMinX = Infinity, allMaxX = -Infinity;
                    for (let i = 0; i < position.count; i++) {
                        const x = position.getX(i);
                        if (x < allMinX) allMinX = x;
                        if (x > allMaxX) allMaxX = x;
                    }

                    console.log('  Using NORMAL-based floor detection (faces with normals pointing up)');
                    console.log('  Mesh X range (LOCAL):', allMinX.toFixed(2), 'to', allMaxX.toFixed(2));

                    // Extract floor vertices, UVs, and faces
                    const floorVertices = [];
                    const floorUVs = [];
                    const floorIndices = [];
                    const vertexMap = new Map(); // old index -> new index

                    // RALPH FIX: The tunnel is rotated 90 degrees on Y axis
                    // LOCAL X axis (-248 to +248) becomes WORLD Z axis (tunnel length)
                    // LOCAL Z axis becomes WORLD X axis (tunnel width)
                    //
                    // So filtering by LOCAL X was limiting WORLD Z (wrong!)
                    // We want to limit WORLD X (tunnel width), which is LOCAL Z
                    //
                    // Find Z range (which becomes world X after rotation)
                    let allMinZ = Infinity, allMaxZ = -Infinity;
                    for (let i = 0; i < position.count; i++) {
                        const z = position.getZ(i);
                        if (z < allMinZ) allMinZ = z;
                        if (z > allMaxZ) allMaxZ = z;
                    }
                    console.log('  Mesh Z range (LOCAL, becomes world X):', allMinZ.toFixed(2), 'to', allMaxZ.toFixed(2));

                    // ROAD BOUNDS: Filter on LOCAL Z (which becomes WORLD X)
                    // Use center portion for the walkable road width
                    const meshZCenter = (allMinZ + allMaxZ) / 2;
                    const meshZWidth = allMaxZ - allMinZ;
                    const roadWidthPercent = 0.50;  // Use middle 50% of mesh Z range for road
                    const roadHalfWidth = (meshZWidth * roadWidthPercent) / 2;

                    const roadMinZ = meshZCenter - roadHalfWidth;
                    const roadMaxZ = meshZCenter + roadHalfWidth;

                    console.log('  Road Z bounds (center ' + (roadWidthPercent*100) + '%, becomes world X):', roadMinZ.toFixed(2), 'to', roadMaxZ.toFixed(2));

                    // Get UV attribute if it exists
                    const uv = geometry.attributes.uv;
                    const hasUV = !!uv;

                    // Identify floor faces within road X bounds
                    // NEW: Use FACE NORMAL direction instead of Y-threshold to detect floor
                    const indexArray = index ? index.array : null;
                    const faceCount = indexArray ? indexArray.length / 3 : position.count / 3;

                    let totalFloorFaces = 0;
                    let roadFaces = 0;

                    // Helper to calculate face normal
                    const v0 = new THREE.Vector3();
                    const v1 = new THREE.Vector3();
                    const v2 = new THREE.Vector3();
                    const cb = new THREE.Vector3();
                    const ab = new THREE.Vector3();

                    for (let i = 0; i < faceCount; i++) {
                        const i0 = indexArray ? indexArray[i * 3] : i * 3;
                        const i1 = indexArray ? indexArray[i * 3 + 1] : i * 3 + 1;
                        const i2 = indexArray ? indexArray[i * 3 + 2] : i * 3 + 2;

                        // Get LOCAL Z coordinates (which become world X after 90deg Y rotation)
                        const z0 = position.getZ(i0);
                        const z1 = position.getZ(i1);
                        const z2 = position.getZ(i2);

                        // Get triangle vertices
                        v0.set(position.getX(i0), position.getY(i0), position.getZ(i0));
                        v1.set(position.getX(i1), position.getY(i1), position.getZ(i1));
                        v2.set(position.getX(i2), position.getY(i2), position.getZ(i2));

                        // Calculate face normal
                        cb.subVectors(v2, v1);
                        ab.subVectors(v0, v1);
                        cb.cross(ab).normalize();

                        // Floor faces have normal pointing mostly upward (+Y direction)
                        // Lower threshold to capture more floor faces (including slightly angled)
                        const isFloorFace = cb.y > 0.3;

                        // Filter by LOCAL Z (which becomes WORLD X after rotation)
                        const inRoadBounds = z0 >= roadMinZ && z0 <= roadMaxZ &&
                                           z1 >= roadMinZ && z1 <= roadMaxZ &&
                                           z2 >= roadMinZ && z2 <= roadMaxZ;

                        if (isFloorFace) totalFloorFaces++;
                        // Extract floor faces within road bounds only
                        if (isFloorFace && inRoadBounds) {
                            roadFaces++;
                            // Add vertices if not already added
                            [i0, i1, i2].forEach(oldIdx => {
                                if (!vertexMap.has(oldIdx)) {
                                    vertexMap.set(oldIdx, floorVertices.length / 3);

                                    // Transform vertices to WORLD space using child's world matrix
                                    const localVertex = new THREE.Vector3(
                                        position.getX(oldIdx),
                                        position.getY(oldIdx),
                                        position.getZ(oldIdx)
                                    );
                                    localVertex.applyMatrix4(worldMatrix);

                                    // Store world-space vertex
                                    floorVertices.push(
                                        localVertex.x,
                                        localVertex.y,
                                        localVertex.z
                                    );

                                    // Copy or generate UV coordinates
                                    if (hasUV) {
                                        floorUVs.push(
                                            uv.getX(oldIdx),
                                            uv.getY(oldIdx)
                                        );
                                    } else {
                                        // Generate UVs from world position
                                        floorUVs.push(localVertex.x / 100, localVertex.z / 100);
                                    }
                                }
                            });

                            // Add face indices
                            floorIndices.push(
                                vertexMap.get(i0),
                                vertexMap.get(i1),
                                vertexMap.get(i2)
                            );
                        }
                    }

                    console.log('  Total floor faces (normal.y > 0.3):', totalFloorFaces);
                    console.log('  Road faces (after Z filtering for width):', roadFaces);
                    console.log('  Filtered out:', totalFloorFaces - roadFaces, 'faces');

                    // Calculate actual X bounds of extracted vertices
                    let extractedMinX = Infinity, extractedMaxX = -Infinity;
                    for (let i = 0; i < floorVertices.length; i += 3) {
                        const x = floorVertices[i];
                        if (x < extractedMinX) extractedMinX = x;
                        if (x > extractedMaxX) extractedMaxX = x;
                    }

                    console.log('  Extracted ROAD surface: ' + (floorVertices.length / 3) + ' vertices, ' + (floorIndices.length / 3) + ' faces');
                    console.log('  Road Z bounds filter (local): ' + roadMinZ.toFixed(2) + ' to ' + roadMaxZ.toFixed(2));
                    console.log('  Actual extracted world X range:', extractedMinX.toFixed(2), 'to', extractedMaxX.toFixed(2));
                    console.log('  UVs:', hasUV ? 'copied from original' : 'generated from position');

                    if (floorVertices.length > 0) {
                        // Create new geometry for floor
                        const floorGeometry = new THREE.BufferGeometry();
                        floorGeometry.setAttribute('position', new THREE.Float32BufferAttribute(floorVertices, 3));
                        floorGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(floorUVs, 2));
                        floorGeometry.setIndex(floorIndices);
                        floorGeometry.computeVertexNormals();

                        // VALIDATE geometry
                        console.log('  🔍 GEOMETRY VALIDATION:');
                        console.log('    Vertices:', floorVertices.length / 3);
                        console.log('    Indices:', floorIndices.length);
                        console.log('    UVs:', floorUVs.length / 2);
                        console.log('    First vertex:', floorVertices.slice(0, 3));
                        console.log('    First index:', floorIndices.slice(0, 3));
                        console.log('    Has NaN:', floorVertices.some(v => isNaN(v)));

                        // DEBUG: Wireframe to see structure
                        const checkeredMaterial = new THREE.MeshBasicMaterial({
                            color: 0xff0000,  // BRIGHT RED
                            wireframe: true,  // WIREFRAME MODE
                            side: THREE.DoubleSide
                        });

                        // Create floor mesh
                        floorMesh = new THREE.Mesh(floorGeometry, checkeredMaterial);

                        // CRITICAL: Vertices are in LOCAL space (from child.geometry.attributes.position)
                        // The mesh needs to be a CHILD of urbanEnvironment to inherit the 100x scale and transforms

                        floorMesh.name = 'ExtractedFloor_STAGE1';
                        floorMesh.renderOrder = 1;  // Render after tunnel (default is 0)
                        floorMesh.position.y = 0.1;  // Slight offset above ground to avoid Z-fighting

                        console.log('  ✅ Floor vertices transformed to WORLD space');

                        // Add directly to scene (vertices already in world coordinates)
                        scene.add(floorMesh);

                        // DEBUG: Add a simple box at floor center to verify rendering
                        const debugBox = new THREE.Mesh(
                            new THREE.BoxGeometry(10, 0.5, 10),
                            new THREE.MeshStandardMaterial({
                                color: 0x00ff00,  // GREEN
                                emissive: 0x00ff00,
                                emissiveIntensity: 1.0
                            })
                        );
                        debugBox.position.set(-30, 0.5, -200);  // Near character position
                        scene.add(debugBox);
                        console.log('  🟢 DEBUG: Added green box at character position for visibility test');

                        // DEBUG: Log world-space bounding box
                        floorMesh.updateMatrixWorld(true);
                        const floorWorldBox = new THREE.Box3().setFromObject(floorMesh);
                        console.log('  === FLOOR VERIFICATION ===');
                        console.log('  Floor World Y: min=' + floorWorldBox.min.y.toFixed(2) + ', max=' + floorWorldBox.max.y.toFixed(2));
                        console.log('  Floor World X: min=' + floorWorldBox.min.x.toFixed(2) + ', max=' + floorWorldBox.max.x.toFixed(2));
                        console.log('  Floor World Z: min=' + floorWorldBox.min.z.toFixed(2) + ', max=' + floorWorldBox.max.z.toFixed(2));
                        console.log('  Character at: X=' + (-29.05).toFixed(2) + ', Y=1.00, Z=' + (-200.28).toFixed(2));

                        const containsChar = floorWorldBox.min.x < -29 && -29 < floorWorldBox.max.x &&
                                             floorWorldBox.min.z < -200 && -200 < floorWorldBox.max.z;
                        console.log('  Floor contains character position:', containsChar ? '✅ YES' : '❌ NO');

                        console.log('  ✅ Floor mesh added to scene (vertices in world space)');
                        console.log('  ✅ Checkered texture applied');
                        console.log('✅ STAGE 1 COMPLETE: Checkered floor should be visible!');
                    } else {
                        console.log('❌ No floor vertices found - threshold may be incorrect');
                    }
                }
            });

            // Calculate bounding box for collision (using adjusted box)
            const size = boxAfter.getSize(new THREE.Vector3());
            const center = boxAfter.getCenter(new THREE.Vector3());

            console.log('Tunnel bounds:', {
                center: { x: center.x.toFixed(2), y: center.y.toFixed(2), z: center.z.toFixed(2) },
                size: { x: size.x.toFixed(2), y: size.y.toFixed(2), z: size.z.toFixed(2) }
            });

            // Calculate tunnel start and end positions
            const tunnelStart = center.z - (size.z / 2);
            const tunnelEnd = center.z + (size.z / 2);
            console.log('Tunnel extends from Z=' + tunnelStart.toFixed(2) + ' to Z=' + tunnelEnd.toFixed(2));

            // Reposition officer near the EXIT end but still fully enclosed
            if (shooterModel) {
                // Calculate from bounding box (this worked before)
                const box = new THREE.Box3().setFromObject(urbanEnvironment);
                const tunnelMinZ = box.min.z;
                const tunnelMaxZ = box.max.z;
                const tunnelLength = tunnelMaxZ - tunnelMinZ;

                console.log('=== TUNNEL DIMENSIONS ===');
                console.log('Tunnel MinZ (ENTRANCE):', tunnelMinZ.toFixed(2));
                console.log('Tunnel MaxZ (EXIT):', tunnelMaxZ.toFixed(2));
                console.log('Tunnel Length:', tunnelLength.toFixed(2), 'units');

                // Use configured starting position for Animation Testing mode
                const startPos = LEVEL_CONFIG.ANIMATION_TESTING_START;

                console.log('=== STARTING POSITION ===');
                console.log('Using saved starting point:', startPos.description);
                console.log('Position - X:', startPos.x.toFixed(2), 'Y:', startPos.y.toFixed(2), 'Z:', startPos.z.toFixed(2));

                shooterModel.position.set(startPos.x, startPos.y, startPos.z);
                shooterModel.rotation.y = startPos.rotation;

                console.log('Officer ACTUAL position:', {
                    x: shooterModel.position.x.toFixed(2),
                    y: shooterModel.position.y.toFixed(2),
                    z: shooterModel.position.z.toFixed(2)
                });

                // Camera BEHIND officer (lower Z = behind when facing positive Z)
                // TUNNEL VISIBILITY FIX: Lower camera height to see walls on sides better
                camera.position.set(startPos.x, startPos.y + 1.5, startPos.z - 6);
                camera.lookAt(startPos.x, startPos.y + 0.5, startPos.z + 20);

                console.log('Camera position:', {
                    x: camera.position.x.toFixed(2),
                    y: camera.position.y.toFixed(2),
                    z: camera.position.z.toFixed(2)
                });
                console.log('Camera looking at (toward exit):', {
                    x: startPos.x.toFixed(2),
                    y: (startPos.y + 0.5).toFixed(2),
                    z: (startPos.z + 10).toFixed(2)
                });
            } else {
                console.log('WARNING: Officer not loaded yet when tunnel finished loading');
            }

            // Create collision areas for the tunnel
            createTunnelColliders();

            // Add distance markers so user can see progress
            addTunnelMarkers(tunnelStart, tunnelEnd);
        },
        // onProgress
        (xhr) => {
            if (xhr.lengthComputable) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                console.log('Tunnel road loading: ' + percent + '%');
            }
        },
        // onError
        (error) => {
            console.error('Error loading tunnel road:', error);
        }
    );
}

function createTunnelColliders() {
    // Add collision boxes for tunnel walls - TIGHT to visual structure only
    if (!urbanEnvironment) {
        console.log('Cannot create tunnel colliders - environment not loaded');
        return;
    }

    // Get bounding box for tunnel length
    const box = new THREE.Box3().setFromObject(urbanEnvironment);
    const tunnelMinZ = box.min.z;
    const tunnelMaxZ = box.max.z;
    const tunnelLength = tunnelMaxZ - tunnelMinZ;
    const tunnelCenterZ = (tunnelMinZ + tunnelMaxZ) / 2;

    console.log('=== TUNNEL DIMENSIONS ===');
    console.log('Z range (length):', tunnelMinZ.toFixed(2), 'to', tunnelMaxZ.toFixed(2));

    const wallThickness = 2;      // Thin walls
    const wallHeight = 10;        // Tall walls

    // COLLISION WALLS based on step tracker data
    // User walked X: -38.11 to +10.93
    // Scale 800 gives visual walls at approximately X=+/-30 (before shift)
    // With shift of -13.5:
    // Left wall: -30 + (-13.5) = -43.5 (contains user at X=-38)
    // Right wall: +30 + (-13.5) = +16.5 (contains user at X=+11)
    const leftWallX = -43.5;    // Left wall position (shifted)
    const rightWallX = 16.5;    // Right wall position (shifted)

    // Left wall - at visible tunnel left edge
    addCollider(
        leftWallX,             // X position (visible structure left)
        tunnelCenterZ,         // Z position (center of tunnel)
        wallThickness,         // Width of wall
        tunnelLength,          // Depth (extends full tunnel length)
        wallHeight,            // Height
        'Tunnel Left Wall (Visible Structure)'
    );

    // Right wall - at visible tunnel right edge
    addCollider(
        rightWallX,            // X position (visible structure right)
        tunnelCenterZ,         // Z position (center of tunnel)
        wallThickness,         // Width of wall
        tunnelLength,          // Depth (extends full tunnel length)
        wallHeight,            // Height
        'Tunnel Right Wall (Visible Structure)'
    );

    console.log('=== COLLISION WALLS FOR STEP TRACKER TUNNEL ===');
    console.log('Left wall at X=' + leftWallX);
    console.log('Right wall at X=' + rightWallX);
    console.log('Playable width: 60 units (contains step tracker X range -38 to +11)');

    // CLEAN VIEW - collision walls work, don't need to show them
    toggleCollisionDebug(false);
}

function addWallMarkers(leftX, rightX, tunnelMinZ, tunnelMaxZ) {
    console.log('Adding visual wall markers at EXACT tunnel edges...');

    // Add markers every 30 units along the walls
    const markerInterval = 30;
    const numMarkers = Math.floor((tunnelMaxZ - tunnelMinZ) / markerInterval);

    for (let i = 0; i <= numMarkers; i++) {
        const zPos = tunnelMinZ + (i * markerInterval);

        // Left wall marker (bright cyan sphere) - at EXACT left edge
        const leftMarkerGeometry = new THREE.SphereGeometry(1.5, 8, 8);
        const leftMarkerMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 1
        });
        const leftMarker = new THREE.Mesh(leftMarkerGeometry, leftMarkerMaterial);
        leftMarker.position.set(leftX, 2, zPos);
        scene.add(leftMarker);

        // Right wall marker (bright magenta sphere) - at EXACT right edge
        const rightMarkerGeometry = new THREE.SphereGeometry(1.5, 8, 8);
        const rightMarkerMaterial = new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            emissive: 0xff00ff,
            emissiveIntensity: 1
        });
        const rightMarker = new THREE.Mesh(rightMarkerGeometry, rightMarkerMaterial);
        rightMarker.position.set(rightX, 2, zPos);
        scene.add(rightMarker);
    }

    console.log(`Added ${numMarkers * 2} wall markers at EXACT positions:`);
    console.log(`  CYAN (left) at X=${leftX.toFixed(2)}`);
    console.log(`  MAGENTA (right) at X=${rightX.toFixed(2)}`);
}

function addTunnelMarkers(tunnelStart, tunnelEnd) {
    // Add distance markers every 20 units with different colors
    console.log('Adding tunnel distance markers...');

    const markerInterval = 20;
    const totalDistance = tunnelEnd - tunnelStart;
    const numMarkers = Math.floor(totalDistance / markerInterval);

    const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];

    for (let i = 0; i <= numMarkers; i++) {
        const zPos = tunnelStart + (i * markerInterval);
        const distance = Math.abs(zPos - tunnelStart);
        const color = colors[i % colors.length];

        console.log('Creating marker ' + i + ' at Z=' + zPos.toFixed(2) + ' showing "' + distance + 'm"');

        // Create marker text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 256;

        // Draw background
        context.fillStyle = '#000000';
        context.fillRect(0, 0, 512, 256);

        // Draw text in alternating colors
        context.fillStyle = color;
        context.font = 'Bold 100px Arial';
        context.textAlign = 'center';
        context.fillText(distance + 'm', 256, 160);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);

        sprite.position.set(-5, 5, zPos); // Left wall, higher up
        sprite.scale.set(3, 1.5, 1); // Reasonable size
        scene.add(sprite);

        // Add duplicate on right side
        const sprite2 = sprite.clone();
        sprite2.position.set(5, 5, zPos);
        scene.add(sprite2);
    }

    // Add EXIT marker at the end
    const exitCanvas = document.createElement('canvas');
    const exitContext = exitCanvas.getContext('2d');
    exitCanvas.width = 512;
    exitCanvas.height = 256;

    exitContext.fillStyle = '#000000';
    exitContext.fillRect(0, 0, 512, 256);
    exitContext.fillStyle = '#00ff00';
    exitContext.font = 'Bold 120px Arial';
    exitContext.textAlign = 'center';
    exitContext.fillText('START', 256, 180);

    const exitTexture = new THREE.CanvasTexture(exitCanvas);
    const exitSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: exitTexture }));
    exitSprite.position.set(0, 5, tunnelEnd - 10);
    exitSprite.scale.set(6, 3, 1); // Reasonable size
    scene.add(exitSprite);

    // Add bright light at exit
    const exitLight = new THREE.PointLight(0x00ff00, 5, 80);
    exitLight.position.set(0, 3, tunnelEnd - 5);
    scene.add(exitLight);

    console.log('Added ' + (numMarkers + 1) + ' distance markers and exit sign');
}

function addCollider(x, z, width, depth, height, label = '') {
    const collider = {
        x: x,
        z: z,
        width: width,
        depth: depth,
        height: height,
        label: label
    };

    environmentColliders.push(collider);

    // Create debug visualization (wireframe box) - BRIGHT AND VISIBLE
    const debugGeometry = new THREE.BoxGeometry(width, height, depth);
    const debugMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true,
        transparent: false,  // Make it fully opaque
        opacity: 1.0,
        depthTest: false,    // Render on top of everything
        depthWrite: false
    });
    const debugBox = new THREE.Mesh(debugGeometry, debugMaterial);
    debugBox.position.set(x, height / 2, z);
    debugBox.renderOrder = 999; // Render last (on top)
    scene.add(debugBox);
    debugCollisionBoxes.push(debugBox);

    // Also add a solid colored box to make it even more visible
    const solidGeometry = new THREE.BoxGeometry(width * 0.9, height * 0.9, depth * 0.9);
    const solidMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide
    });
    const solidBox = new THREE.Mesh(solidGeometry, solidMaterial);
    solidBox.position.set(x, height / 2, z);
    scene.add(solidBox);
    debugCollisionBoxes.push(solidBox);

    console.log(`✅ Collider added: ${label || 'Unnamed'} at X=${x}, Z=${z} (Width=${width}, Depth=${depth}, Height=${height})`);
}

function toggleCollisionDebug(show) {
    debugCollisionBoxes.forEach(box => {
        box.visible = show;
    });
}

function checkEnvironmentCollision(newX, newZ, radius = 0.5) {
    for (const collider of environmentColliders) {
        // AABB collision with character radius
        const halfWidth = collider.width / 2;
        const halfDepth = collider.depth / 2;

        // Check if character circle intersects with box
        const closestX = Math.max(collider.x - halfWidth, Math.min(newX, collider.x + halfWidth));
        const closestZ = Math.max(collider.z - halfDepth, Math.min(newZ, collider.z + halfDepth));

        const distanceX = newX - closestX;
        const distanceZ = newZ - closestZ;
        const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;

        if (distanceSquared < (radius * radius)) {
            return true; // Collision detected!
        }
    }
    return false; // No collision
}

// RALPH: Expose for debugging
window.checkEnvironmentCollision = checkEnvironmentCollision;

// ============================================================================
// DEBUG POSITION DASHBOARD
// ============================================================================

let debugDashboard = null;

// ============================================================================
// STEP TRACKER - Records position trail for collision wall placement
// ============================================================================

let stepTracker = {
    isRecording: false,
    steps: [],
    lastRecordedPos: null,
    recordInterval: 0.1, // Record every 0.1 seconds
    timeSinceLastRecord: 0,
    startTime: null,
    minDistance: 0.5, // Only record if moved at least 0.5 units

    start() {
        this.isRecording = true;
        this.steps = [];
        this.lastRecordedPos = null;
        this.startTime = Date.now();
        this.timeSinceLastRecord = 0;
        console.log('📍 Step Tracker: Recording STARTED');
        updateStepTrackerUI();
    },

    stop() {
        this.isRecording = false;
        console.log('📍 Step Tracker: Recording STOPPED');
        console.log('Total steps recorded:', this.steps.length);
        this.exportData();
        updateStepTrackerUI();
    },

    reset() {
        this.steps = [];
        this.lastRecordedPos = null;
        this.timeSinceLastRecord = 0;
        console.log('📍 Step Tracker: Data RESET');
        updateStepTrackerUI();
    },

    record(delta) {
        if (!this.isRecording || !shooterModel) return;

        this.timeSinceLastRecord += delta;

        // Record at intervals
        if (this.timeSinceLastRecord >= this.recordInterval) {
            const currentPos = {
                x: shooterModel.position.x,
                y: shooterModel.position.y,
                z: shooterModel.position.z
            };

            // Only record if moved significantly or first position
            if (!this.lastRecordedPos || this.hasMovedSignificantly(currentPos)) {
                const timeElapsed = ((Date.now() - this.startTime) / 1000).toFixed(2);

                this.steps.push({
                    step: this.steps.length + 1,
                    time: timeElapsed,
                    x: currentPos.x.toFixed(2),
                    y: currentPos.y.toFixed(2),
                    z: currentPos.z.toFixed(2),
                    distance: this.lastRecordedPos ? this.calculateDistance(currentPos) : 0
                });

                this.lastRecordedPos = currentPos;
                updateStepTrackerUI();
            }

            this.timeSinceLastRecord = 0;
        }
    },

    hasMovedSignificantly(currentPos) {
        if (!this.lastRecordedPos) return true;

        const dx = currentPos.x - this.lastRecordedPos.x;
        const dy = currentPos.y - this.lastRecordedPos.y;
        const dz = currentPos.z - this.lastRecordedPos.z;
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

        return distance >= this.minDistance;
    },

    calculateDistance(currentPos) {
        const dx = currentPos.x - this.lastRecordedPos.x;
        const dy = currentPos.y - this.lastRecordedPos.y;
        const dz = currentPos.z - this.lastRecordedPos.z;
        return Math.sqrt(dx*dx + dy*dy + dz*dz).toFixed(2);
    },

    exportData() {
        console.log('=== STEP TRACKER DATA EXPORT ===');
        console.log('Total Steps:', this.steps.length);
        console.log('Duration:', ((Date.now() - this.startTime) / 1000).toFixed(2), 'seconds');
        console.log('\nPosition Data:');
        this.steps.forEach(step => {
            console.log(`Step ${step.step}: X=${step.x}, Y=${step.y}, Z=${step.z} (${step.time}s, moved ${step.distance}m)`);
        });

        // Calculate bounds
        if (this.steps.length > 0) {
            const xValues = this.steps.map(s => parseFloat(s.x));
            const zValues = this.steps.map(s => parseFloat(s.z));

            console.log('\n=== COLLISION BOUNDS ===');
            console.log('X Range:', Math.min(...xValues).toFixed(2), 'to', Math.max(...xValues).toFixed(2));
            console.log('Z Range:', Math.min(...zValues).toFixed(2), 'to', Math.max(...zValues).toFixed(2));
        }
    },

    getTotalDistance() {
        return this.steps.reduce((sum, step) => sum + parseFloat(step.distance), 0).toFixed(2);
    },

    getBounds() {
        if (this.steps.length === 0) return null;

        const xValues = this.steps.map(s => parseFloat(s.x));
        const zValues = this.steps.map(s => parseFloat(s.z));

        return {
            minX: Math.min(...xValues).toFixed(2),
            maxX: Math.max(...xValues).toFixed(2),
            minZ: Math.min(...zValues).toFixed(2),
            maxZ: Math.max(...zValues).toFixed(2)
        };
    }
};

let stepTrackerDashboard = null;

function createDebugDashboard() {
    if (debugDashboard) return; // Already created

    const dashboard = document.createElement('div');
    dashboard.id = 'debug-dashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        color: #00ff00;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        padding: 15px;
        border: 2px solid #00ff00;
        border-radius: 8px;
        z-index: 1000;
        min-width: 300px;
        pointer-events: auto;
    `;

    dashboard.innerHTML = `
        <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px; color: #ffff00;">
            🎯 DEBUG POSITION TRACKER
        </div>
        <div style="margin-bottom: 8px;">
            <strong>Position:</strong><br>
            X: <span id="debug-pos-x">0.00</span><br>
            Y: <span id="debug-pos-y">0.00</span><br>
            Z: <span id="debug-pos-z">0.00</span>
        </div>
        <div style="margin-bottom: 8px;">
            <strong>Rotation:</strong> <span id="debug-rot-y">0.00</span>°
        </div>
        <div style="margin-bottom: 8px;">
            <strong>Velocity:</strong><br>
            X: <span id="debug-vel-x">0.00</span><br>
            Z: <span id="debug-vel-z">0.00</span>
        </div>
        <hr style="border-color: #00ff00; margin: 10px 0;">
        <div style="font-weight: bold; margin-bottom: 5px;">TELEPORT TO:</div>
        <div style="margin-bottom: 5px;">
            X: <input type="number" id="teleport-x" step="0.1" value="0" style="width: 70px; background: #222; color: #0f0; border: 1px solid #0f0; padding: 2px;">
            Y: <input type="number" id="teleport-y" step="0.1" value="1" style="width: 70px; background: #222; color: #0f0; border: 1px solid #0f0; padding: 2px;">
            Z: <input type="number" id="teleport-z" step="0.1" value="0" style="width: 70px; background: #222; color: #0f0; border: 1px solid #0f0; padding: 2px;">
        </div>
        <button id="teleport-btn" style="
            background: #00ff00;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 5px;
        ">TELEPORT NOW</button>
        <div style="margin-top: 10px; font-size: 11px; color: #888;">
            Quick presets:<br>
            <button class="preset-btn" data-x="${LEVEL_CONFIG.ANIMATION_TESTING_START.x}" data-y="${LEVEL_CONFIG.ANIMATION_TESTING_START.y}" data-z="${LEVEL_CONFIG.ANIMATION_TESTING_START.z}">STARTING POINT</button>
            <button class="preset-btn" data-x="0" data-y="1" data-z="0">Tunnel center</button>
        </div>
    `;

    // Add preset button styles
    const style = document.createElement('style');
    style.textContent = `
        .preset-btn {
            background: #333;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .preset-btn:hover {
            background: #0f0;
            color: #000;
        }
    `;
    document.head.appendChild(style);

    document.body.appendChild(dashboard);
    debugDashboard = dashboard;

    // Add teleport button functionality
    document.getElementById('teleport-btn').addEventListener('click', () => {
        if (!shooterModel) return;

        const x = parseFloat(document.getElementById('teleport-x').value);
        const y = parseFloat(document.getElementById('teleport-y').value);
        const z = parseFloat(document.getElementById('teleport-z').value);

        shooterModel.position.set(x, y, z);
        console.log(`TELEPORTED to X:${x.toFixed(2)}, Y:${y.toFixed(2)}, Z:${z.toFixed(2)}`);
    });

    // Add preset button functionality
    dashboard.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.getElementById('teleport-x').value = btn.dataset.x;
            document.getElementById('teleport-y').value = btn.dataset.y;
            document.getElementById('teleport-z').value = btn.dataset.z;
        });
    });

    console.log('Debug dashboard created');
}

function updateDebugDashboard() {
    if (!debugDashboard || !shooterModel) return;

    // Update position
    document.getElementById('debug-pos-x').textContent = shooterModel.position.x.toFixed(2);
    document.getElementById('debug-pos-y').textContent = shooterModel.position.y.toFixed(2);
    document.getElementById('debug-pos-z').textContent = shooterModel.position.z.toFixed(2);

    // Update rotation (convert from radians to degrees)
    const rotDeg = (shooterModel.rotation.y * 180 / Math.PI).toFixed(2);
    document.getElementById('debug-rot-y').textContent = rotDeg;

    // Update velocity
    if (MazeController.velocity) {
        document.getElementById('debug-vel-x').textContent = MazeController.velocity.x.toFixed(2);
        document.getElementById('debug-vel-z').textContent = MazeController.velocity.z.toFixed(2);
    }
}

function removeDebugDashboard() {
    if (debugDashboard) {
        debugDashboard.remove();
        debugDashboard = null;
    }
}

// ============================================================================
// STEP TRACKER DASHBOARD UI
// ============================================================================

function createStepTrackerDashboard() {
    if (stepTrackerDashboard) return; // Already created

    const dashboard = document.createElement('div');
    dashboard.id = 'step-tracker-dashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 80px;
        left: 20px;
        background: rgba(0, 0, 0, 0.9);
        color: #00ff00;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        padding: 15px;
        border: 2px solid #ff6600;
        border-radius: 8px;
        z-index: 1000;
        width: 350px;
        max-height: 80vh;
        overflow-y: auto;
        pointer-events: auto;
    `;

    dashboard.innerHTML = `
        <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px; color: #ff6600;">
            📍 STEP TRACKER
        </div>

        <div style="margin-bottom: 10px; padding: 10px; background: rgba(255,102,0,0.1); border: 1px solid #ff6600; border-radius: 4px;">
            <div style="font-weight: bold; margin-bottom: 5px;">STATUS: <span id="tracker-status" style="color: #ffff00;">READY</span></div>
            <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                <button id="tracker-start-btn" style="
                    flex: 1;
                    background: #00ff00;
                    color: #000;
                    border: none;
                    padding: 8px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                ">START</button>
                <button id="tracker-stop-btn" style="
                    flex: 1;
                    background: #ff0000;
                    color: #fff;
                    border: none;
                    padding: 8px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                " disabled>STOP</button>
            </div>
            <button id="tracker-reset-btn" style="
                width: 100%;
                background: #666;
                color: #fff;
                border: none;
                padding: 6px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
            ">RESET DATA</button>
        </div>

        <div style="margin-bottom: 10px; padding: 8px; background: rgba(0,255,0,0.05); border: 1px solid #0f0; border-radius: 4px;">
            <div style="font-weight: bold; margin-bottom: 5px; color: #ffff00;">SUMMARY:</div>
            <div>Steps: <span id="tracker-step-count" style="color: #fff;">0</span></div>
            <div>Distance: <span id="tracker-distance" style="color: #fff;">0.00</span>m</div>
            <div>Time: <span id="tracker-time" style="color: #fff;">0.00</span>s</div>
        </div>

        <div id="tracker-bounds" style="display: none; margin-bottom: 10px; padding: 8px; background: rgba(255,255,0,0.1); border: 1px solid #ff0; border-radius: 4px;">
            <div style="font-weight: bold; margin-bottom: 5px; color: #ffff00;">COLLISION BOUNDS:</div>
            <div style="font-size: 11px;">
                X: <span id="tracker-min-x">0</span> to <span id="tracker-max-x">0</span><br>
                Z: <span id="tracker-min-z">0</span> to <span id="tracker-max-z">0</span>
            </div>
        </div>

        <div style="margin-bottom: 5px; font-weight: bold; border-bottom: 1px solid #ff6600; padding-bottom: 5px;">
            RECORDED STEPS:
        </div>

        <div id="tracker-steps-list" style="
            max-height: 300px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.4;
        ">
            <div style="color: #888; text-align: center; padding: 20px;">
                No steps recorded yet.<br>
                Click START to begin tracking.
            </div>
        </div>

        <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 10px; color: #888;">
            💡 TIP: Walk the path, click STOP, then screenshot this panel to send collision data.
        </div>
    `;

    document.body.appendChild(dashboard);
    stepTrackerDashboard = dashboard;

    // Add button event listeners
    document.getElementById('tracker-start-btn').addEventListener('click', () => {
        stepTracker.start();
        document.getElementById('tracker-start-btn').disabled = true;
        document.getElementById('tracker-stop-btn').disabled = false;
    });

    document.getElementById('tracker-stop-btn').addEventListener('click', () => {
        stepTracker.stop();
        document.getElementById('tracker-start-btn').disabled = false;
        document.getElementById('tracker-stop-btn').disabled = true;
    });

    document.getElementById('tracker-reset-btn').addEventListener('click', () => {
        if (confirm('Reset all recorded steps?')) {
            stepTracker.reset();
            document.getElementById('tracker-start-btn').disabled = false;
            document.getElementById('tracker-stop-btn').disabled = true;
        }
    });

    console.log('Step Tracker Dashboard created');
}

function updateStepTrackerUI() {
    if (!stepTrackerDashboard) return;

    // Update status
    const statusEl = document.getElementById('tracker-status');
    if (stepTracker.isRecording) {
        statusEl.textContent = '🔴 RECORDING';
        statusEl.style.color = '#ff0000';
    } else if (stepTracker.steps.length > 0) {
        statusEl.textContent = '✅ COMPLETED';
        statusEl.style.color = '#00ff00';
    } else {
        statusEl.textContent = 'READY';
        statusEl.style.color = '#ffff00';
    }

    // Update summary
    document.getElementById('tracker-step-count').textContent = stepTracker.steps.length;
    document.getElementById('tracker-distance').textContent = stepTracker.getTotalDistance();

    if (stepTracker.startTime) {
        const elapsed = ((Date.now() - stepTracker.startTime) / 1000).toFixed(2);
        document.getElementById('tracker-time').textContent = elapsed;
    }

    // Update bounds (if we have data)
    const bounds = stepTracker.getBounds();
    if (bounds) {
        document.getElementById('tracker-bounds').style.display = 'block';
        document.getElementById('tracker-min-x').textContent = bounds.minX;
        document.getElementById('tracker-max-x').textContent = bounds.maxX;
        document.getElementById('tracker-min-z').textContent = bounds.minZ;
        document.getElementById('tracker-max-z').textContent = bounds.maxZ;
    } else {
        document.getElementById('tracker-bounds').style.display = 'none';
    }

    // Update steps list
    const listEl = document.getElementById('tracker-steps-list');
    if (stepTracker.steps.length === 0) {
        listEl.innerHTML = `
            <div style="color: #888; text-align: center; padding: 20px;">
                No steps recorded yet.<br>
                Click START to begin tracking.
            </div>
        `;
    } else {
        let html = '<table style="width: 100%; border-collapse: collapse;">';
        html += '<tr style="background: rgba(255,102,0,0.2); font-weight: bold;"><td>#</td><td>X</td><td>Y</td><td>Z</td><td>Dist</td></tr>';

        // Show last 20 steps (most recent first)
        const recentSteps = stepTracker.steps.slice(-20).reverse();
        recentSteps.forEach(step => {
            html += `
                <tr style="border-bottom: 1px solid rgba(255,102,0,0.2);">
                    <td>${step.step}</td>
                    <td>${step.x}</td>
                    <td>${step.y}</td>
                    <td>${step.z}</td>
                    <td style="color: #888;">${step.distance}</td>
                </tr>
            `;
        });

        if (stepTracker.steps.length > 20) {
            html += `<tr><td colspan="5" style="color: #888; text-align: center; padding: 5px;">... showing last 20 of ${stepTracker.steps.length} steps</td></tr>`;
        }

        html += '</table>';
        listEl.innerHTML = html;
    }
}

function removeStepTrackerDashboard() {
    if (stepTrackerDashboard) {
        stepTrackerDashboard.remove();
        stepTrackerDashboard = null;
    }
}

// ============================================================================
// COLLISION DETECTION
// ============================================================================

function checkCollisions() {
    if (PlayerController.isInvincible || !playerModel) return;

    // Check obstacle collisions
    obstacles.forEach(obstacle => {
        if (obstacle.active) {
            const distance = Math.abs(obstacle.mesh.position.z - playerModel.position.z);
            const sameColumn = obstacle.lane === PlayerController.targetLane;

            if (distance < 1.5 && sameColumn) {
                handlePlayerHit();
                obstacle.deactivate();
            }
        }
    });

    // Check enemy collision
    if (enemyModel) {
        const distance = playerModel.position.distanceTo(enemyModel.position);
        if (distance < 2) {
            if (GameState.currentMode === 'CHASE') {
                GameState.score += 1000;
                console.log('Caught enemy! +1000');
                enemyModel.position.z = -20;
            } else {
                handlePlayerHit();
            }
        }
    }
}

function handlePlayerHit() {
    GameState.lives--;
    PlayerController.isInvincible = true;
    PlayerController.invincibilityTimer = 2;

    console.log(`Hit! Lives: ${GameState.lives}`);

    if (GameState.lives <= 0) {
        gameOver();
    }
}

// ============================================================================
// UI OVERLAY
// ============================================================================

const UI = {
    overlay: null,

    init() {
        this.overlay = document.getElementById('ui-overlay');
        this.updateUI();
    },

    updateUI() {
        if (GameState.screen === 'START') {
            this.overlay.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; padding: 20px;">
                    <h1 style="font-size: 52px; color: #4fc3f7; margin-bottom: 10px;">GAP TAG</h1>
                    <p style="font-size: 18px; margin-bottom: 40px; color: #888;">Get your tooth back!</p>

                    <h2 style="font-size: 28px; margin-bottom: 30px;">Select Level</h2>

                    <div style="display: flex; gap: 30px; flex-wrap: wrap; justify-content: center;">
                        <!-- Level 1: Chase the Opp -->
                        <div onclick="selectLevel('chase')" style="
                            width: 250px;
                            padding: 30px;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            border-radius: 15px;
                            cursor: pointer;
                            transition: transform 0.2s, box-shadow 0.2s;
                            pointer-events: all;
                            border: 3px solid transparent;
                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 10px 30px rgba(102,126,234,0.5)'"
                           onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                            <div style="font-size: 40px; margin-bottom: 15px;">🏃</div>
                            <h3 style="font-size: 24px; margin-bottom: 10px; color: white;">Chase the Opp</h3>
                            <p style="font-size: 14px; color: #ddd; margin-bottom: 15px;">Catch the enemy while dodging obstacles!</p>
                            <div style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 20px; display: inline-block;">
                                <span style="font-size: 12px; font-weight: bold;">▶ PLAY NOW</span>
                            </div>
                        </div>

                        <!-- Level 2: Animation Testing -->
                        <div onclick="selectLevel('shoot')" style="
                            width: 250px;
                            padding: 30px;
                            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
                            border-radius: 15px;
                            cursor: pointer;
                            transition: transform 0.2s, box-shadow 0.2s;
                            pointer-events: all;
                            border: 3px solid transparent;
                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 10px 30px rgba(33,150,243,0.5)'"
                           onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                            <div style="font-size: 40px; margin-bottom: 15px;">🎬</div>
                            <h3 style="font-size: 24px; margin-bottom: 10px; color: white;">Animation Testing</h3>
                            <p style="font-size: 14px; color: #ddd; margin-bottom: 15px;">Test officer animations on a grid!</p>
                            <div style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 20px; display: inline-block;">
                                <span style="font-size: 12px; font-weight: bold;">▶ TEST NOW</span>
                            </div>
                        </div>
                    </div>

                    <p style="font-size: 14px; color: #666; margin-top: 40px;">Tap LEFT or RIGHT to move • Catch the enemy to score</p>
                </div>
            `;
        } else if (GameState.screen === 'PLAYING') {
            const modeColor = GameState.selectedLevel === 'shoot' ? 'rgba(33, 150, 243, 0.8)' :
                             GameState.currentMode === 'CHASE' ? 'rgba(79, 195, 247, 0.8)' : 'rgba(239, 83, 80, 0.8)';
            const modeText = GameState.selectedLevel === 'shoot' ? '🎬 ANIMATION TESTING' :
                            GameState.currentMode === 'CHASE' ? 'CHASE MODE' : '!!! RUN AWAY !!!';

            // Show controls for testing mode
            const mazeControls = GameState.selectedLevel === 'shoot' ? `
                <div style="position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 15px 25px; border-radius: 10px; color: white; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">Test Officer Animations</div>
                    <div style="font-size: 14px; margin-bottom: 5px;">WASD or Arrow Keys to Move</div>
                    <div style="font-size: 14px; margin-bottom: 5px; color: #ffeb3b;">Number Keys 1-4 to Rotate Manually</div>
                    <div style="font-size: 12px; margin-bottom: 5px; color: #aaa;">1=Forward | 2=Right | 3=Back | 4=Left | 0=Auto</div>
                    <div style="display: flex; gap: 8px; justify-content: center; margin-top: 10px;">
                        <div style="padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 12px;">Move = Run</div>
                        <div style="padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 12px;">Stop = Idle</div>
                    </div>
                </div>
            ` : '';

            this.overlay.innerHTML = `
                <div style="position: absolute; top: 20px; left: 20px; color: white; font-size: 18px;">
                    <div>Score: ${GameState.score}</div>
                    <div style="color: #ffeb3b;">Best: ${GameState.highScore}</div>
                </div>
                <div style="position: absolute; top: 20px; right: 20px; color: white; font-size: 24px;">
                    ${'❤️'.repeat(GameState.lives)}${'🖤'.repeat(GameState.maxLives - GameState.lives)}
                </div>
                <div style="position: absolute; top: 0; left: 0; width: 100%; padding: 10px; text-align: center; background: ${modeColor}; color: white; font-size: 24px; font-weight: bold;">
                    ${modeText}
                </div>
                ${mazeControls}
            `;
        } else if (GameState.screen === 'GAMEOVER') {
            this.overlay.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; background: rgba(0,0,0,0.8);">
                    <h1 style="font-size: 48px; color: #ef5350; margin-bottom: 30px;">GAME OVER</h1>
                    <p style="font-size: 28px; margin-bottom: 10px;">Score: ${GameState.score}</p>
                    ${GameState.isNewHighScore ?
                        '<p style="font-size: 24px; color: #ffeb3b;">NEW HIGH SCORE!</p>' :
                        '<p style="font-size: 18px; color: #888;">Best: ' + GameState.highScore + '</p>'}
                    <p style="font-size: 24px; color: #4fc3f7; margin-top: 60px; pointer-events: all; cursor: pointer;" onclick="resetGame()">TAP TO PLAY AGAIN</p>
                </div>
            `;
        }
    }
};

// ============================================================================
// GAME FLOW
// ============================================================================

function selectLevel(level) {
    GameState.selectedLevel = level;
    console.log('Selected level:', level);

    if (level === 'chase') {
        startGame();
    } else if (level === 'shoot') {
        startShootingGame();
    }
}

function startGame() {
    // Default to chase mode if no level selected
    if (!GameState.selectedLevel) {
        GameState.selectedLevel = 'chase';
    }

    // Remove debug dashboards (only for Animation Testing mode)
    removeDebugDashboard();
    removeStepTrackerDashboard();

    GameState.screen = 'PLAYING';
    GameState.isRunning = true;
    GameState.score = 0;
    GameState.lives = 3;
    PlayerController.init();
    EnemyController.init();
    ObstacleManager.reset();
    UI.updateUI();

    console.log('Starting game with level:', GameState.selectedLevel);
}

function startShootingGame() {
    GameState.selectedLevel = 'shoot';
    GameState.screen = 'PLAYING';
    GameState.isRunning = true;
    GameState.score = 0;
    GameState.lives = 3;

    console.log('Starting Animation Testing mode...');

    // Clear any existing chase mode objects
    if (playerModel) scene.remove(playerModel);
    if (enemyModel) scene.remove(enemyModel);
    obstacles.forEach(obs => obs.deactivate());
    obstacles.length = 0;

    // Clear road segments (simple)
    roadSegments.forEach(segment => {
        scene.remove(segment.mesh);
    });
    roadSegments.length = 0;

    // Clear 3D road models
    roadModels.forEach(roadModel => {
        scene.remove(roadModel);
    });
    roadModels.length = 0;

    // Build the testing ground
    buildTestingGround();

    // RALPH FIX: Don't set hardcoded camera position here
    // Camera will be positioned correctly when tunnel/officer finish loading
    // Initial default camera (will be overridden)
    camera.position.set(0, 8, 15);
    camera.lookAt(0, 0, 0);

    // Load officer character
    loadOfficerCharacter();

    UI.updateUI();

    // RALPH: Create debug dashboards
    createDebugDashboard();
    createStepTrackerDashboard();
}

function gameOver() {
    GameState.screen = 'GAMEOVER';
    GameState.isRunning = false;

    if (GameState.score > GameState.highScore) {
        GameState.highScore = GameState.score;
        GameState.isNewHighScore = true;
        localStorage.setItem('gaptag_highscore', GameState.highScore);
    } else {
        GameState.isNewHighScore = false;
    }

    UI.updateUI();
}

function resetGame() {
    startGame();
}

function loadHighScore() {
    const saved = localStorage.getItem('gaptag_highscore');
    GameState.highScore = saved ? parseInt(saved, 10) : 0;
}

// ============================================================================
// MAIN GAME LOOP
// ============================================================================

function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    // Always update animations so they loop smoothly regardless of game state
    if (playerMixer) playerMixer.update(delta);
    if (enemyMixer) enemyMixer.update(delta);
    if (shooterMixer) shooterMixer.update(delta);

    // Apply gun controls every frame for real-time dashboard updates
    if (subMachineGun && GameState.selectedLevel === 'shoot') {
        // Auto-detect officer facing direction and update gun accordingly
        if (shooterModel) {
            const rotation = shooterModel.rotation.y;
            // Normalize rotation to 0-2π range
            const normalizedRotation = ((rotation % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);

            // Determine direction based on rotation (in degrees for clarity)
            const degrees = normalizedRotation * 180 / Math.PI;
            let direction = 'forward';

            // Forward: 315° to 45° (0° ± 45°)
            if (degrees >= 315 || degrees < 45) {
                direction = 'forward';
            }
            // Right: 45° to 135° (90° ± 45°)
            else if (degrees >= 45 && degrees < 135) {
                direction = 'right';
            }
            // Backward: 135° to 225° (180° ± 45°)
            else if (degrees >= 135 && degrees < 225) {
                direction = 'backward';
            }
            // Left: 225° to 315° (270° ± 45°)
            else if (degrees >= 225 && degrees < 315) {
                direction = 'left';
            }

            GunControls.updateForDirection(direction);
        }

        subMachineGun.rotation.set(GunControls.rotationX, GunControls.rotationY, GunControls.rotationZ);
        subMachineGun.position.set(GunControls.positionX, GunControls.positionY, GunControls.positionZ);
        subMachineGun.scale.set(GunControls.scale, GunControls.scale, GunControls.scale);
    }

    if (GameState.screen === 'PLAYING' && GameState.isRunning) {
        // Update score
        GameState.score += Math.floor(delta * 10);

        if (GameState.selectedLevel === 'chase') {
            // CHASE MODE logic
            PlayerController.update(delta);
            EnemyController.update(delta);
            ObstacleManager.update(delta);
            EnvironmentManager.update(delta);
            checkCollisions();

            // Update camera to follow player
            if (playerModel) {
                camera.position.x = playerModel.position.x;
                camera.position.z = playerModel.position.z + 8;
                camera.lookAt(playerModel.position.x, playerModel.position.y + 1, playerModel.position.z - 5);
            }

            // Only update UI for chase mode (score display)
            UI.updateUI();
        } else if (GameState.selectedLevel === 'shoot') {
            // ANIMATION TESTING MODE
            MazeController.update(delta);

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.userData.lifetime += delta;

                // Move bullet
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                // Remove if expired or out of bounds
                if (bullet.userData.lifetime >= bullet.userData.maxLifetime ||
                    Math.abs(bullet.position.x) > 100 ||
                    Math.abs(bullet.position.z) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }

            // Update smoke particles
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const smoke = smokeParticles[i];
                smoke.userData.lifetime += delta;

                // Move smoke
                smoke.position.add(smoke.userData.velocity.clone().multiplyScalar(delta));

                // Expand and fade out
                const lifeProgress = smoke.userData.lifetime / smoke.userData.maxLifetime;
                smoke.scale.setScalar(1 + lifeProgress * 2); // Grow larger
                smoke.material.opacity = 0.6 * (1 - lifeProgress); // Fade out

                // Slow down
                smoke.userData.velocity.multiplyScalar(0.95);

                // Remove if expired
                if (smoke.userData.lifetime >= smoke.userData.maxLifetime) {
                    scene.remove(smoke);
                    smokeParticles.splice(i, 1);
                }
            }

            // Update bullet casings
            const gravity = -9.8;
            const groundLevel = 0.15; // Height of casing cylinder when on ground
            const bounceDamping = 0.4; // Energy loss on bounce

            for (let i = bulletCasings.length - 1; i >= 0; i--) {
                const casing = bulletCasings[i];
                casing.userData.lifetime += delta;

                if (!casing.userData.onGround) {
                    // Apply gravity
                    casing.userData.velocity.y += gravity * delta;

                    // Update position
                    casing.position.add(casing.userData.velocity.clone().multiplyScalar(delta));

                    // Rotate (tumbling)
                    casing.rotation.x += casing.userData.rotationVelocity.x * delta;
                    casing.rotation.y += casing.userData.rotationVelocity.y * delta;
                    casing.rotation.z += casing.userData.rotationVelocity.z * delta;

                    // Check if hit ground
                    if (casing.position.y <= groundLevel) {
                        casing.position.y = groundLevel;

                        // Bounce
                        if (Math.abs(casing.userData.velocity.y) > 0.5) {
                            casing.userData.velocity.y = -casing.userData.velocity.y * bounceDamping;
                            casing.userData.velocity.x *= 0.8;
                            casing.userData.velocity.z *= 0.8;
                            casing.userData.rotationVelocity.multiplyScalar(0.6);
                        } else {
                            // Settled on ground
                            casing.userData.onGround = true;
                            casing.userData.velocity.set(0, 0, 0);
                            casing.userData.rotationVelocity.set(0, 0, 0);
                        }
                    }
                }

                // Remove old casings after 30 seconds
                if (casing.userData.lifetime > 30) {
                    scene.remove(casing);
                    bulletCasings.splice(i, 1);
                }
            }

            // Camera follows character from behind - tunnel runs along Z-axis at Y=-5
            if (shooterModel) {
                const cameraOffsetY = 3;   // Height above character
                const cameraOffsetZ = 12;  // Distance behind character (tunnel runs along Z)

                // RALPH FIX: Character now faces toward EXIT (positive Z)
                // So camera should be BEHIND (lower Z) looking FORWARD (higher Z)
                camera.position.set(
                    shooterModel.position.x,
                    shooterModel.position.y + cameraOffsetY,
                    shooterModel.position.z - cameraOffsetZ  // BEHIND = lower Z
                );

                // Look ahead toward the exit (positive Z direction)
                camera.lookAt(
                    shooterModel.position.x,
                    shooterModel.position.y,
                    shooterModel.position.z + 20  // FORWARD = higher Z
                );
            } else {
                // Default camera position
                camera.position.set(0, 8, 15);
                camera.lookAt(0, 0, 0);
            }

            // DO NOT call UI.updateUI() every frame for shoot mode!
            // This would destroy and recreate the gun dashboard sliders,
            // making them impossible to interact with.
            // The UI is set once when starting shoot mode.

            // RALPH: Update debug position dashboard
            updateDebugDashboard();

            // RALPH: Record step tracker data
            stepTracker.record(delta);
        }
    }

    renderer.render(scene, camera);
}

// ============================================================================
// INITIALIZATION
// ============================================================================

function init() {
    console.log('Gap Tag 3D - Initializing...');

    // Create scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // RALPH: Expose scene for debugging
    window.scene = scene;

    // Create camera (3rd person view)
    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(0, 6, 8);
    camera.lookAt(0, 0, 0);

    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Enhanced rendering for realistic lighting
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2; // Slightly brighter exposure
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    document.body.appendChild(renderer.domElement);

    // Clock for animations
    clock = new THREE.Clock();

    // Initialize systems
    Input.init();
    UI.init();
    loadHighScore();

    // Load environment
    EnvironmentManager.init();
    ObstacleManager.init();

    // Load characters
    loadPlayerCharacter();
    loadEnemyCharacter();

    // Handle window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start animation loop
    animate();

    console.log('Gap Tag 3D - Ready!');
}

// Make functions global for UI
window.selectLevel = selectLevel;
window.startGame = startGame;
window.resetGame = resetGame;

// Start when ready
if (document.readyState === 'complete') {
    init();
} else {
    window.addEventListener('load', init);
}
